[
  
  {
    "title": "Enterprise IAM",
    "url": "/posts/EnterpriseIAM/",
    "categories": "Security, General",
    "tags": "IAM, auth",
    "date": "2020-04-10 00:00:00 +0900",
    





    
    "snippet": "Identity and Access Management는 권한이 있는 사용자가 필요한 자원을 원하는 시기에 접근할 수 있게 하는 보안 원칙으로, 쉽게 생각되겠지만, 신경써야할 부분이 많다. 사용자가 누구인지 확실히 해야할 필요가 있고, 사용자의 접속 과정이 불편하진 않은지 생각해야하만 한다. 모든 보안 장치들을 통과해야만 권한을 얻을 수 있도록 만드는...",
    "content": "Identity and Access Management는 권한이 있는 사용자가 필요한 자원을 원하는 시기에 접근할 수 있게 하는 보안 원칙으로, 쉽게 생각되겠지만, 신경써야할 부분이 많다. 사용자가 누구인지 확실히 해야할 필요가 있고, 사용자의 접속 과정이 불편하진 않은지 생각해야하만 한다. 모든 보안 장치들을 통과해야만 권한을 얻을 수 있도록 만드는게 능사가 아니기 때문이다.Enterprise Identity and Access Management일반적인 기업의 IAM 솔루션의 구성 요소를 살펴보자.AD/LDAP사용자 정보 저장소가 필요하다. Active Directory를 종종 사용한다.(꼭 AD일 필요는 없다)Single Sign-On꽤 일찍부터 기업들은 Single Sign-On(SSO)에 투자를 해왔다. 처음엔 회사 내에서 사용할 목적으로 비표준 방식의 SSO를 구현했다.Identity Federation (Federated SSO)외부 파트너와 같이 일하고, SaaS와 같은 서비스를 시작하면서 SSO와 같은 통합 계정이 필요해졌고, 표준 통합 계정으로 여러 공급 업체의 제품을 통합할 수 있다.Multi-factor Authentication다단계 인증을 사용하면 사용자에 대한 더 높은 신뢰도를 가질 수 있기 때문에, 다단계(Multi-factor) 인증이 필요하다.Automated ProvisioningSaaS의 사용자가 증가함에 따라, 많은 회사들이 임직원 관리 시스템에 사용자를 연결하기 시작했다. HRMS 기반의 사용자 관리, 요청/승인 과정, SaaS 또는 내부 시스템 할당(Provisioning) 등의 내용이 포함된다.Compliance - Audit, Reporting AnalyticsIAM은 모니터링하고 감시하는 기능이 필요하다. 역할 분리, 자격 증명등의 내용이 포함된다.Authentication and AuthorizationAuthentication(AuthN) 은 사용자가 누구인지 증명하는 행위다. 일반적으로 username과 password를 사용하거나, 더 높은 신뢰도를 위해 인증서를 사용한다. MFA 같은 것을 사용할 수도 있다.Authorization(AuthZ) 은 사용자가 접근할 수 있는 대상을 결정한다. 예를 들어, 로그인한 후에 공유 파일을 열고 내용을 확인할 때, 그 파일에 대한 권한이 사용자의 Authorization이다.Basic Local Identity and Access Management개발자는 애플리케이션 개발 요청을 받으면 요구 사항 분석을 시작하고 비지니스 로직을 만들기 시작한다.사용자별 설정, 환경설정 그리고 접근 권한 등을 관리하기 위해 서로 다른 사용자들을 나누기 위한 방법이 필요해진다. 그래서 개발자는 애플리케이션마다 사용자 저장소를 만들고 인증 로직을 만들어야 한다. 물론 코드는 재사용될 것이다.무슨 일이 발생했을까? 애플리케이션들은 각각 변경될 것이고 상황은 매우 안좋아질 것이다. 비지니스 로직을 관리하는 개발자는 이제 사용자 저장소를 보호하는데 신경 써야할 것이다. 인증 과정에 문제가 생기는지, 해킹당하지 않는지 보장하는 일은 개발자에겐 매우 고통스러운 일이다.사용자 입장에서도 반드시 아이디와 비밀번호를 입력해야 하고, 종종 취약한 비밀번호를 사용하거나 재사용하는 문제가 발생한다. 관리자 또한 매우 고통스러운데, 먼저, 각 애플리케이션에 사용자를 생성하고, 사용자가 탈퇴하면 위와 같은 문제를 해결하기 위해 각각의 애플리케이션에서 반드시 사용자를 비활성화 해야 한다.Modern Identity Management and Access현대에 쓰이는 인증 모델은 클레임 기반 모델로써, 개발자는 클레임을 받아주는 더 단순한 로직으로 애플리케이션의 인증 과정을 바꾸었다.신뢰성(TRUST)은 애플리케이션과 Identity Provider(IdP) 사이에서 시작된다. IdP는 인증이나 권한을 확인해주는 서비스로 보면 쉽다. 애플리케이션은 단순히 IdP에서 전송된 클레임만 받으면 된다.애플리케이션은 사용자 정보 설정과 적절한 권한을 위해 로컬 사용자 저장소를 가지고 있지만, 비밀번호를 관리하진 않는다. 사용자가 애플리케이션에 직접 인증을 시도하지 않기 때문이다. 대신 사용자는 IdP에서 인증을 받아야 한다.사용자가 애플리케이션에 접속하고자 하면, 클레임이나 접속 토큰이 IdP에 의해 생성되고 애플리케이션에 보내진다. IdP는 모든 애플리케이션에 클레임을 발행할 수 있다.클레임 기반 접속 방식은 개발자, 사용자, 관리자 모두에게 좋다. 개발자들은 강력한 인증 방법을 만들 필요가 없고 사용자 비밀번호를 보호해야할 필요가 없다. 만약 인증 방법이 변경되야 한다면 IdP에서 바꾸고 애플리케이션은 바꾸지 않고 남겨두면 된다. 사용자들은 IdP에서 한번 인증을 받으면 모든 애플리케이션에 간편하게 접속할 수 있다. 관리자들은 사용자가 퇴사할 경우 IdP에서 사용자를 비활성화하는 즉시 모든 애플리케이션에 적용할 수 있다.Real world example좀 더 깊게 클레임에 대한 개념을 이해하기 위해 일반적인 상황에 맞추어 보자.여행을 간다고 상상해보자. 목적지를 정하고 공항에 도착했다.  체크인 카운터(IdP)에 가서 여권을 제시하고 티켓 구입 여부를 확인한다.  체크인 직원은 여권을 확인하고 탑승권(Claim)을 발급해준다.  보안체크를 통과하고 탑승할 차례다. 탑승권을 게이트(SP) 직원에게 보여준다.게이트는 체크인 카운터를 신뢰(Trust)한다.  탑승권은 서명(Signed)되어 있고, 게이트는 조작여부를 알 수 있다.탑승권(Claim)에는 이름, 비행편 등의 정보(attribute)가 들어있다.Creating Trust클레임 기반 인증 모델에선 신뢰(Trust)가 핵심이다. 제대로 동작하기 위해선 애플리케이션이 IdP를 반드시 신뢰해야 한다. 신뢰 관계를 구축하는 방법은 표준에 따라 다양한데, 인증서를 교환하는 방식이 많이 쓰인다. 신뢰 관계를 만들 때 종종 파일이나 파일에 걸린 링크와 같은 일반적인 메타데이터를 사용해야 한다. 애플리케이션은 다른 애플리케이션과 이 정보를 공유하는데, 메타 데이터 파일을 사용하면 신뢰 설정이 간단해진다.  메타 데이터는 보통 인증서를 포함하고 있고, 로그인/로그아웃 URL 그리고 시스템 사용에 필요한 값 들을 가지고 있다. 메타 데이터 파일을 사용하지 않는 경우 이런 값들을 직접 입력해줘야 한다. 어떤 경우, 인증서 대신 시스템 ID와   비밀번호를 사용하는 경우도 있다.Identity Management이제 클레임 기반 인증에 대한 이해가 생겼지만 대부분의 애플리케이션에는 여전히 사용자 정보를 관리해야 한다.  오늘날 많은 회사에선 사용자를 생성하고 관리하기 위해 중앙 집중식 인적 자원 시스템을 사용하고 있다. 이 시스템은 IdP에 사용자를 보내주고, IdP는 애플리케이션에 사용자를 전달한다.Metadirectory하지만, 대기업의 경우 더 많은 중앙 집중식 시스템이 필요하고, 다양한 사용자 저장소가 있다. 따라서 메타 디렉토리를 중앙 집중식 단일 지점으로 통합한다. 이 메타 디렉토리는 인적 자원 시스템에 의해 제공된다. 메타 디렉토리에서 사용자는 다른 시스템 중 하나와 동기화된다. 이 방법으로 사용자의 전체 수명주기는 메타 디렉토리를 기반으로 동작한다.Realm/Security Domain클레임 기반 인증에 대해 이야기 할 때 영역(Realm) 또는 보안 도메인(Security Domain)이란 단어를 자주 들어봤을 것이다. 영역이나 보안 도메인은 기본적으로 신뢰(Trust)의 범위다. 영역(Realm) 안에서 각 항목들은 서로를 신뢰한다. 그리고 클레임은 시스템에 대한 접속을 위해 사용된다.Multiple Realms여러 영역(Realm) 이나 보안 도메인(Security Doamin)이 있다면, 기본적으로 이들은 서로를 신뢰할 수 없다. 영역(Realm) A의 애플리케이션에 접속할 수 있도록 IdP(A) 에서 발급받은 클레임은 영역(Realm) B에서 사용할 수 없다.Federation위와 같은 이유로 페더레이션(Federation, 통합)의 개념이 등장했다. 페더레이션을 사용하면 서로 다른 두 영역간 신뢰 관계를 설정할 수 있기 때문에 영역(Realm) B의 사용자가 영역(Realm) A의 애플리케이션에 접근할 수 있다. 사용자는 자신의 로컬 IdP를 이용하여 인증한 다음 다른 영역(Realm)의 애플리케이션에 쉽게 접속할 수 있다.  사용자 관리는 각 영역(Realm) 내에서 처리된다. 즉, 영역(Realm) B의 사용자 관리자가 사용자에게 권한을 부여하지 않으면 사용자는 더 이상 접속 권한을 갖지 못한다. 영역(Realm) A의 관리자에게 알릴 필요도 없다. 사용자는 영역(Realm) B에서 한 번 권한을 잃게 되면 모든 곳에서 권한을 잃는다.Level of Assurance영역(Realm)간 통합 시, 인증 수준에 대한 부분을 빼놓을 수 없는데, 다른 영역(Realm)의 프로세스, 시스템, 사용자, 관리자를 얼마나 신뢰하는지에 대한 것이다. 영역(Realm) B에서 생성된 사용자를 인증하기 위한 적절한 식별 수단을 제공해야 한다. 그리고 인증을 위해 다단계 인증이 제공된다. 내 보증(Assurance) 수준은 상당히 높지만 사용자가 단순히 익명의 양식을 채우고 계정을 만들 수 있고 오직 사용자명과 비밀번호만으로 인증한다면 내 보증(Assurance) 수준은 당연히 꽤 낮을 것이다. 많은 클레임에 사용자 인증 방법에 대한 정보가 포함되어 있다는 사실에 이를 연결시킬 수 있다. 서로 다른 두 영역간에 신뢰가 설정되어 있지만 사용자가 너무 약한 인증 방법을 사용하여 인증된 경우, 접근을 허용하지 않을 것이다. 사용자를 사용자의 영역으로 다시 돌려보내고 더 높은 수준의 인증의 메시지를 요청할 수 있다.The Claim클레임(Claim)과 관련하여 다양한 표준이 있는데, 이것은 클레임(Claim)에 다양한 내용이 포함될 수 있음을 의미한다. 하지만 최소한 고유한 사용자 식별자가 포함되어 있어야 한다. 클레임(Claim)은 서명(Sign)되는 경우도 있다. 이 경우 엔티티는 클레임(Claim)이 조작되지 않았는지 검증할 수 있다. 요즘엔 추가 보호를 위해 전체 클레임(Claim)을 암호화 하는 것이 일반화되어 있다. 어떤 클레임(Claim)에는 사용자가 인증 관리를 하는지 여부에 대한 정보가 들어있다. 이상하게 들릴 수 있는데, 사용자가 특정 인증 방법을 수행할 수 있는지 여부를 확인하기 위해 클레임(Claim)에 전달하는 경우도 있다. 인증 방법이 약하다고 판단되면 더 강력한 인증 방법을 사용하도록 사용자를 돌려보낼 수 있다. 어떤 표준은 다른 표준이 매우 엄격하게 다루는 클레임(Claim)에 매우 유연하다. 이메일 주소, 이름같은 것들을 확인하기도 한다. 클레임(Claim)에 역할, 그룹, 멤버십과 같은 것들을 전달한다.Claim Transformation클레임 트랜스포메이션(Claim Transformation)의 두 가지 예시가 있다.첫 번째로, 한 가지 타입의 클레임으로 IdP에 권한을 얻기 위해 접속한다. Kerberos를 사용하였다. 인증되면, IdP는 새로운 종류의 클레임과 함께 다음 과정을 진행한다. 다음 과정은 SAML 기반의 클레임으로 진행된다.또 다른 방법으로, 예시처럼 클레임의 내용을 바꾼다면 사용자는 username과 password로 IdP에 개인을 인증한다. 그러나 애플리케이션은 개인 사용자를 구분할 필요가 없기때문에 클레임에서 필요한 것은 그룹 멤버십이나 직원의 역할 정도다.Chained Federation클레임이 종료되고 새 클레임이 발행되는 경우 홉을 통해 전달되지 않은 각 홉으로 연합 엔티티 체인을 작성할 수 있습니다.이 예에서 애플리케이션은 체인의 마지막 ID 제공자 만 신뢰하며 마지막으로 멀티 팩터를 명확히하기 위해 인증 또는 MFA.통합 엔티티 체인을 구축 할 수 있다. 각 단계에서 클레임이 종료되고 새로운 클레임이 발행되고 클레임은 각 단계를 통과하지 않는다. 애플리케이션은 체인의 마지막 IdP만 신뢰한다.Multi-Factor Authentication (MFA)MFA는 최소한 두 가지 다른 요소를 필요로 해야한다는 것을 의미한다. 일반적으로 비밀번호, 핀, 인증서 또는 지문같은 것이다. username과 password를 사용했더라도 여전히 한 가지 요소만 사용한 것이다. 이것은 사용자를 귀찮게 했을뿐 신뢰성을 높이지는 못한 것이다."
  },
  
  {
    "title": "ZSH Settings",
    "url": "/posts/ZSHSettings/",
    "categories": "Computer, Environments",
    "tags": "mac, zsh",
    "date": "2020-02-14 00:00:00 +0900",
    





    
    "snippet": "bash shell을 너무 오래 써오다보니, zsh로 조금 늦게 넘어오게 되었다. 난 bash가 좋은데..(익숙해서)Change shell to zshThe default interactive shell is now zsh.To update your account to use zsh, please run `chsh -s /bin/zsh`.for mor...",
    "content": "bash shell을 너무 오래 써오다보니, zsh로 조금 늦게 넘어오게 되었다. 난 bash가 좋은데..(익숙해서)Change shell to zshThe default interactive shell is now zsh.To update your account to use zsh, please run `chsh -s /bin/zsh`.for more details, please visit https://support.apple.com/kb/HT208050.foo@bar:~$ chsh -s /bin/zshOH MY ZSH 설치foo@bar:~$ sh -c \"$(curl -fsSL https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh)\"NPM 설정 복사-&gt; ~ cat ~/.bash_profile &gt;&gt; ~/.zshrc-&gt; ~ source ~/.zshrcnpm 명령이 잘 실행되는지 확인.iTerm2 Colour Scheme 변경원하는 걸로 찾아서 변경해봅시다.ZSH Plugin 설치  zsh-auto    -&gt; ~ git clone https://github.com/zsh-users/zsh-autosuggestions ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-autosuggestions        zsh-highlight    -&gt; ~ git clone https://github.com/zsh-users/zsh-syntax-highlighting.git ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-syntax-highlighting      .zshrc 파일에서plugins=(  git  zsh-syntax-highlighting  zsh-autosuggestions)Powerline font 설치Download Meslo LG M Regular for Powerline다운로드 후 설치.사용하고자 하는 IDE 등에서 font-famliy에 Meslo LG M Regular for Powerline 입력ZSH theme 설치.zshrc 파일에서ZSH_THEME=\"agnoster\"-&gt; ~ source ~/.zshrcVIM 꾸미기하는김에..wrkholic84 &gt; vi ~/.vimrcset hlsearchset rulerset autoindentset cindentset nuset ts=4set shiftwidth=4syntax on끝."
  },
  
  {
    "title": "Tor as a SOCKS Proxy",
    "url": "/posts/TorAsASOCKSProxy/",
    "categories": "Security, Web",
    "tags": "proxy",
    "date": "2020-01-12 00:00:00 +0900",
    





    
    "snippet": "요즘 웹 사이트엔 정말 다양한 보안 정책들이 적용되어 있다. 그 중 IP 차단 정책은 모의해킹을 수행할 때 있어서 매우 골칫거리가 아닐 수 없다.IP 차단 정책을 우회할 수 있는 방법이 몇가지 있다. 예를 들자면, VPN을 사용하면 된다. 하지만 VPN은 사실 상 유료 서비스이기 때문에 사용하는데 부담이 된다. 그 대안으로 Tor가 있다. Tor는 무...",
    "content": "요즘 웹 사이트엔 정말 다양한 보안 정책들이 적용되어 있다. 그 중 IP 차단 정책은 모의해킹을 수행할 때 있어서 매우 골칫거리가 아닐 수 없다.IP 차단 정책을 우회할 수 있는 방법이 몇가지 있다. 예를 들자면, VPN을 사용하면 된다. 하지만 VPN은 사실 상 유료 서비스이기 때문에 사용하는데 부담이 된다. 그 대안으로 Tor가 있다. Tor는 무료이고 HTTP를 포함한 모든 프로토콜을 사용할 수 있는 장점이 있다.TorThe Onion Router의 약자다. 한국에선 ‘토르’라고 부르는데 사실 ‘토어’라고 부르는게 맞다. 아무튼 Tor는 전달된 데이터를 익명으로 처리하도록 디자인된 인터넷 네트워크 프로토콜이다. Tor의 동작원리를 보면 알 수 있듯이 목적지까지 한 번에 통신하지 않고, 중간에 여러 노드들을 거쳐 보내기 때문에 최종 목적지에서는 내 IP를 숨길 수 있다.그렇다 하더라도 IP 차단은 피할 수 없다. 여기서 Tor의 진가가 발휘되는데 Exit Node가 목적지로부터 차단 당한 경우 Tor는 새로운 Exit Node를 할당하여 접속할 수 있도록 만들어 준다.  그리고 차단 당한 Node는 Bridges1 로 다시금 역할을 하게 된다.SOCKS ProxySOCKS는 서버와 클라이언트 사이의 TCP/UDP 통신을 프록시 서버를 거쳐 진행하도록 해주는 프로토콜이다. 프록시 서버는 클라이언트의 IP를 숨겨주는 기능을 한다. HTTP Proxy는 HTTP 프로토콜을 지원하는 반면 SOCKS Proxy는 더 낮은 수준에서 Proxy 역할을 한다. SOCKS 4/4a/5 버전이 있는데 앞으로 진행할 내용에선 SOCKS 5를 이용한다.Tor as a SOCKS5 Proxy일반적으로 Tor는 9050번 포트로 SOCKS 연결을 지원한다.(참고로 Tor 브라우저는 9150번 포트로 지원한다) 클라이언트 PC에서 프로그램은 SOCKS5 설정을 통해 Tor의 SOCKS 로 접속할 수 있다. 간단히 단점을 언급하고 지나가자면 Tor 자체가 좀 느리다. 여러 노드를 지나가다보니 느릴 수 밖에 없다.Install Tor (for Mac)Tor는 총 3가지 방법으로 설치할 수 있다. 그 중 Tor 브라우저를 다운로드 받는 것으로 쉽게 설치할 수 있지만, 여기서는 Mac의 brew 라는 패키지 관리자를 통해 Tor 를 설치해볼 것이다. (이렇게 설치하는게 깔끔하고, 원하는 브라우저를 사용할 수 있다는 장점이 있다) Tor를 설치하는 명령어는 아래와 같다.Mac:~ user$ brew install torMac:~ user$ brew install torMac:~ user$ brew services start tortor     started spidey /Users/spidey/Library/LaunchAgents/homebrew.mxcl.tor.plist위와 같이 나오면 Tor 네트워크를 이용할 준비가 된 것이다.Configure Firefox BrowserFirefox 브라우저를 이용해 Tor 네트워크를 이용해볼 것이다. 아래는 설정 화면이다.HTTP 또는 HTTPS 통신은 SOCKS 호스트를 목적지로 먼저 HTTP 프록시 (127.0.0.1:8080)로 요청을 보내게 된다.Configure Burp SuiteHTTP 프록시로 보내진 요청을 확인하기 위해 Burp Suite을 사용한다. 아래는 Burp suite의 설정 화면이다.끝이다. 이제 Firefox 브라우저를 이용해 접속한 웹사이트는 Burp Suite을 통해 Tor 네트워크를 이용하게 된다.Tor를 이용한 IP 차단 우회는 Tor를 건전한 목적으로 유용하게 사용할 수 있는 방법 중 하나다. 속도가 느리다는 단점이 있지만 유료 VPN을 사용할 수 없는 상황이라면 충분히 이용할만한 가치가 있다고 생각한다. 주의할 점은 Tor도 완벽하지 않다는 점이다. 하지만 Tor project 의 준수사항을 잘 지킨다면 안전하게 이용할 수 있다.  1 차단 당한 Exit Node는 Middle Node로 위치를 바꾸어 지속적으로 Tor 네트워크에서 역할을 하게된다."
  },
  
  {
    "title": "Semantic Versioning(SemVer)",
    "url": "/posts/SemanticVersioning/",
    "categories": "Development, General",
    "tags": "versioning",
    "date": "2020-01-06 00:00:00 +0900",
    





    
    "snippet": "어느 정도 규모가 있는 소프트웨어를 개발할 때면 외부 라이브러리를 사용하게된다. 그리고 자연스럽게 라이브러리 의존성 문제를 접하게 된다. 의존성 문제는 라이브러리가 버전 문제로 서로 충돌하여 사용할 수 없게 되는 것이라 이해하면 쉽다.이 문제를 해결하고자 나온 라이브러리 버전 명시 규칙이 있다.라이브러리의 버전은 보통 a.b.c로 표기된다.  첫 번째...",
    "content": "어느 정도 규모가 있는 소프트웨어를 개발할 때면 외부 라이브러리를 사용하게된다. 그리고 자연스럽게 라이브러리 의존성 문제를 접하게 된다. 의존성 문제는 라이브러리가 버전 문제로 서로 충돌하여 사용할 수 없게 되는 것이라 이해하면 쉽다.이 문제를 해결하고자 나온 라이브러리 버전 명시 규칙이 있다.라이브러리의 버전은 보통 a.b.c로 표기된다.  첫 번째 a(Major) 버전이 오르면 기존 버전과 호환되지 않음  두 번째 b(Minor) 버전이 오르면 새로운 기능이 추가된 경우  세 번째 c(Patch) 버전이 오르면 자잘한 버그 수정이 있는 경우예를 들면,libC 1.2.1은 새로운 버전인 libC 2.1.1과 서로 호환되지 않는 API로 구성되어 있을 것이다.libC 1.2.1 버전을 사용하는 A 라는 프로그램이 있다고 가정해보자.A 프로그램은 libC의 버전이 2.1.1로 오르더라도 계속해서 libC 1.2.1 버전을 사용하면서 프로그램의 안정성을 유지할 수 있다.NPM package.json 의 SemVerNodeJS에서 관리하는 라이브러리(패키지)의 버전 관리를 어떻게 하는지 알아보자.  ^2.2.1 : 2.2.1 이상 3.0.0 미만 (2.2.1 이상이면서 같은 Major 버전)  ~2.2.1 : 2.2.1 이상 2.3.0 미만 (2.2.1 이상이면서 같은 Major 버전)  &gt;2.2.1 : 2.2.1 초과 (2.2.2 이상의 버전 사용)  2.2.1 - 3.0.0 : 2.2.1 이상 3.0.0 이하Tild(~)와 Caret(^)의 차이점Tild(~)가 쓰였을 경우 버그가 수정된 최신 버전으로 업데이트 한다.~2.2.1 버전이라면 2.2.* 의 버전을 가져온다.Caret(^)이 쓰였을 경우 호환 가능한 최신 버전으로 업데이트 한다.^2.2.1 버전이라면 2.. 의 버전을 가져온다.  npm semver calculator"
  },
  
  {
    "title": "Dynamic Code Patch with Frida",
    "url": "/posts/Dynamic-Code-Patch-with-Frida/",
    "categories": "Security, Mobile",
    "tags": "frida",
    "date": "2019-08-21 00:00:00 +0900",
    





    
    "snippet": "모든 프로그램은 개발자가 의도한 대로 동작하게 되어있다.(당연한 이야기다.) 보안의 관점에서 프로그램을 바라볼 때, 개발자의 의도를 비틀어 다른 동작을 수행하도록 만드는 공격 방법이 있다. 개발자의 의도와 상관없이 공격자의 의도대로 프로그램이 동작한다면 그 피해는 가늠하기 어렵다. 따라서 보안 점검 시 고의로 코드가 변경되지는 않는지 확인해봐야 한다....",
    "content": "모든 프로그램은 개발자가 의도한 대로 동작하게 되어있다.(당연한 이야기다.) 보안의 관점에서 프로그램을 바라볼 때, 개발자의 의도를 비틀어 다른 동작을 수행하도록 만드는 공격 방법이 있다. 개발자의 의도와 상관없이 공격자의 의도대로 프로그램이 동작한다면 그 피해는 가늠하기 어렵다. 따라서 보안 점검 시 고의로 코드가 변경되지는 않는지 확인해봐야 한다.프로그램을 변경하는 방법은 두 가지가 있다. 프로그램이 실행되지 않은 상태에서 프로그램을 변경하는 정적 코드 패치(Static Code Pathc)와 프로그램을 실행시키는 과정에서 프로그램의 코드를 변경하는 동적 코드 패치(Dynamic Code Patch)가 있다.Android나 iOS는 프로그램이 만들어지기 전에 코드 서명(Code Signing)을 통해 정적(Static)으로 프로그램 코드가 변경되는 것을 막는다. 물론, 공격 과정에서 코드 서명을 임의로 다시 할 수 있다. 하지만 이번엔 동적 코드 패치에 대한 내용을 다루고자 한다. 프로그램은 전혀 건들지 않고, 실행되는 과정에서 프로그램을 어떻게 바꿀 수 있는지 알아보자.Analyze Target Application - iOS대상으로 정한 앱은 공개된 코드로 만들어진 m2048이라는 게임 앱이고, 해킹 방지를 위한 솔루션이 적용된 앱이다.솔루션이 적용된만큼 탈옥폰에서는 앱이 정상적으로 시작되지 않는다. 하지만 솔루션이 탈옥 여부를 확인하기 직전까지는 앱이 동작하기 때문에 분석의 여지는 충분히 있다.프로그램은 Init_Func(0x5d614) 함수부터 시작한다.프로그램의 시작 부분을 더 자세히 확인하기 위해서 IDA를 사용해보자.왼쪽 밑을 보면 솔루션이 적용된 탓으로 코드의 흐름을 따라가기 어렵게 되어 있다.Control-flow flattening이라 부른다. 코드의 흐름이 평평하게 나열된 많은 코드 블록으로 흩어진다.그리고 frida에서 확인한 것과 같이 Init_Func(0x5d614)이 시작된 이후 첫번째 함수 sub_10008A8B4를 호출한다.Aiming프로그램이 실행되는 순간 코드를 패치하여 프로그램의 흐름을 바꿔보자.별 다른 수정을 하지 않는다면 솔루션이 적용된 프로그램이기 때문에 탈옥 탐지 관련 코드가 실행되고 비정상 종료될 것이다. 따라서 이번 코드 패치의 목적은 탈옥 탐지 관련 코드를 건너 뛰는 것이 될 것이다.방법은 매우 다양하겠지만 간단한 패치만으로 목적을 달성해보자. branch 명령만으로 프로그램의 실행 흐름을 변경할 것이다. (ARM64 opcode를 알아야 한다. 참고: opcode converter online)최종적으로 실행하고자 하는 목표 코드는 0x100005a98 주소에 있는 코드다. 목적지를 이곳으로 정한 이유는 IDA로 분석했을 때 앱의 Main 함수로 추측되는 부분이었기 때문이다.그런데, 굳이 중간에 0x2decc 주소를 한 번 거친 후 0x5a98로 분기하는 이유는 ARM64 명령어가 한 번에 이동할 수 있는 거리에 제한이 있기 때문이다. 즉, 0x5d614에서 0x5a98까지 거리가 너무 멀다!!Code Segment코드를 패치하기 전에 프로그램의 코드 영역(Code Segment)의 특징에 대해 간단히 짚고 넘어갈 필요가 있다. 코드 영역은 메모리에 올라갔을 때 쓰기 권한이 없다. 읽기(Read)와 실행(eXecute) 권한만 있다. 코드는 프로그램이 실행되는 동안 변경될 일이 없기 때문에 코드를 읽고 실행하는 권한만 있으면 된다.따라서 우리는 코드 패치를 위해 코드 영역의 속성을 변경해줘야 한다. 전통적으로 많이 쓰이는 Memory protect 기술을 사용해서 속성을 변경할 것이다. (Frida에서 지원한다.)Run Target Application with Frida공격에 쓰인 핵심 코드를 살펴보자.[Line 2] : Init_Func 함수 포인터를 가져온다.[Line 3] : Memory.protect 함수를 이용해서 Init_Func 함수에 쓰기(Write) 속성을 추가한다.[Line 4] :  프로세스의 메모리 중 읽기(Read)/쓰기(Write) 권한이 있는 부분에[Line 7] : [0x77, 0x83, 0x03, 0xD1] 이 있다면[Line 12] : [0x2E, 0x42, 0xFF, 0x17]로 바꾼다.그림으로 설명하자면, 아래와 같다.Init_Func (0x5d614) 함수의 시작 코드 SUB SP, SP #0xE0 [0x77, 0x83, 0x03, 0xD1]를 우리가 원하는 B 0x10002DECC [0x2E 0x42 0xFF 0x17] 로 변경했다. B(Branch)는 프로그램의 실행을 주소값(0x10002DECC)으로 이동시키라는 의미다.실행 결과를 보면 다음과 같다.앞에서 Caller 인 dyld!ImageLoaderMachO::doModInitFunctions는 0x5d614를 호출 했지만, 코드 패치를 통해 우리가 원하는 대로 0x2decc 함수를 호출했다.What about Android so file위와 같은 방식으로 안드로이드의 so(shared object) 파일을 후킹하여 코드 수정을 할 수 있다. Give it a go!iOS, Android 모두 코드 서명 과정을 거쳐 코드 패치 공격으로부터 프로그램을 보호하고 있다. 하지만 Frida를 이용한 동적 코드 패치 공격을 활용하면 코드 서명을 우회하여 우리가 원하는대로 프로그램을 수정할 수 있는 장점이 있다. 특히 탈옥/루팅 방지 보안 솔루션이 적용된 경우 많은 도움이 된다.PDF 다운로드"
  },
  
  {
    "title": "Authentication",
    "url": "/posts/Authentication/",
    "categories": "Development, Authentication",
    "tags": "auth",
    "date": "2019-07-26 00:00:00 +0900",
    





    
    "snippet": "웹 애플리케이션이나 모바일 앱에서 사용자 계정 관리를 하고 있다면 사용자 인증은 반드시 필요한 기능이다. (물론, 계정이 있는 서비스라면 종류에 상관없이 모두 인증 과정이 있어야 하는 것이 맞다.)인증에 대해 먼저 생각해보자. 인증은 사용자를 특정하여 서비스를 제공 할 때 쓰이는 사용자 확인 과정이다. 그리고 어느 서비스든 인증이 이루어지면 서비스를 ...",
    "content": "웹 애플리케이션이나 모바일 앱에서 사용자 계정 관리를 하고 있다면 사용자 인증은 반드시 필요한 기능이다. (물론, 계정이 있는 서비스라면 종류에 상관없이 모두 인증 과정이 있어야 하는 것이 맞다.)인증에 대해 먼저 생각해보자. 인증은 사용자를 특정하여 서비스를 제공 할 때 쓰이는 사용자 확인 과정이다. 그리고 어느 서비스든 인증이 이루어지면 서비스를 받는 동안 인증이 유지될 필요가 있고 서비스 기간이 만료되면 인증을 폐기하거나 종료시켜야 한다. 흔히 이용하는 회원 서비스를 떠올리면 전혀 어렵지 않은 개념이다!하지만 이런 특징을 바탕으로, 웹/모바일 서비스가 이뤄지는 HTTP 프로토콜에 대해 생각해보면 머리가 아파진다. 기본적으로 HTTP는 Stateless 프로토콜이다. 서버 - 클라이언트 간 상태 정보를 유지하고 있지 않는다는 의미다. 첫 번째 요청으로 사용자가 서버로부터 인증을 받았다고 하더라도 두 번째 요청에서 인증 상태를 유지할 수 없다. 따라서 HTTP 서버(웹서버)가 사용자(브라우저 또는 클라이언트 프로그램)의 정보를 식별하고 사용자의 상태를 유지하려면 별도의 방법을 마련해야 한다.HTTP Message Structure서버와 통신에 사용되는 HTTP 요청 메시지의 구조는 오른쪽 그림과 같이 크게 요청 주소(URL), 헤더(Method + Headers) 그리고 본문(Body)로 구분된다. 헤더 부분에 요청 정보가 들어가고, 본문에 서버로 보내고자 하는 데이터가 들어간다. 보통 웹/모바일 서비스의 인증을 위한 정보는 헤더에 포함된다.Simple authentication data in headers초기 웹 서비스는 사용자 인증을 위해 단순히 헤더에 계정 정보를 담아 보내는 방식을 사용하였다.최악의 인증방식이 아닐 수 없는데, 공격자는 마음대로 요청 정보를 가로채 사용자 정보를 알아내고 조작할 수 있었다.  매우 쉽게 구현할 수 있고, 빠르게 인증을 처리할 수 있지만,  보안에 매우 취약하고,  사용자가 요청을 보낼 때마다 계정정보(사용자 ID, PW)를 계속 보내야 하는 문제점이 있다.HTTPS를 사용하면 안전한 방식이라고 말할 수도 있겠다. 하지만, 엔지니어로서 할 말은 아니다!Memberships그렇다면 어떻게 해야할까? 답은 이미 나와있다. 앞서 언급했듯이, 회원 서비스(이용권) 모델을 사용하면 문제를 쉽게 해결할 수 있다.존 윅이 콘티넨탈 호텔의 서비스를 회원 자격으로 이용한다는 가정을 해보자. (영화의 설정과는 조금 다르다.)  존(사용자)이 호텔에 방문하여 신분증을 제시하면,  샤론(호텔 매니저)은 신분증을 바탕으로 호텔 DB에 접속하여 회원 여부를 확인.  샤론은 다시 존이 12시간(만료기간)동안 사용할 수 있는 고유 번호를 생성하고 암호화하여 보관하고,  샤론은 고유 번호에 해당하는 이용권을 발급한다.  샤론은 존에게 이용권 지급하고,  존은 유효 시간동안 신분증 없이 이용권을 제시하면 호텔의 서비스를 자신의 권한 범위 내에서 이용 가능.존은 이용권을 이용하여 신분증 없이도 호텔의 서비스를 간편하게 이용할 수 있게 되었다. 신분 정보가 노출될 위험이 줄어들었고, 서비스를 이용하기 위해 매번 신분증을 보여줄 필요도 없다.Cookie and Session같은 아이디어를 웹 통신에 적용시킨 것이 세션(고유번호)과 쿠키(이용권)다. 서버와 클라이언트간 세션과 쿠키가 어떻게 생성되고 이용되는지 그림으로 살펴보자.  사용자는 서버에 인증 요청(+계정 정보(ID/PW))을 보낸다.  서버는 계정 정보를 회원 DB에서 확인하고 사용자에게 고유한 값을 부여한다.  부여한 고유값을 암호화하여 세션 저장소에 저장한다.  세션 저장소에 저장된 고유값에 해당하는 세션ID를 발급한다.  발급한 세션ID를 사용자에게 전달하고, 사용자는 세션 ID를 쿠키에 저장한다.  사용자는 발급받은 세션ID를 요청 헤더(쿠키)에 담아 서비스 요청 시 본인이 누구인지 알린다.  서버는 헤더(쿠키)에 담긴 세션ID를 세션 저장소에서 확인하여 사용자가 누구인지 판단한다.  서버는 사용자의 권한에 맞는 서비스를 제공한다.서버에는 세션 저장소라는 공간이 추가로 필요하고, 이 곳에는 세션ID와 서버가 관리하고자 하는 사용자의 정보를 저장하고 있다. 별도의 DB(Redis)를 설정하지 않고 메모리에 저장할 수 있지만 이중화가 불가능하고 서버를 재시작하면 세션 정보가 완전히 사라지는 문제가 있다. 마찬가지로 사용자는 쿠키 저장소를 자신의 하드디스크 어딘가에 마련해두고 서버로부터 전달 받은 세션ID를 쿠키 저장소에 저장하고 있다가 인증정보가 필요한 서비스를 요청할 때 세션ID를 HTTP 헤더(쿠키)에 넣어 보낸다.  세션은 서버가 가지고 있는 정보 / 쿠키는 세션 정보를 확인하기 위한 열쇠(세션ID)  쿠키값으로만 인증을 하는 경우 암호화했다고 하더라도 앞서 설명한 Simple Authenticaion data in headers 의 방식과 동일하며, 책임은 사용자에게 있음. - 보안과 상관없는 경우에만 사용할 수 있도록 제한.      세션을 사용할 경우 책임은 서버에 있음. - 서버가 해킹당하는 것이 훨씬 어렵기 때문에 세션을 사용하도록 권고.    쿠키 정보(세션ID) 자체만으로는 노출된다 하더라도 큰 의미가 없고,  서버는 세션ID만 확인하는 것으로 사용자를 식별할 수 있어 사용이 편하다.  서버에 세션 저장소라는 추가 공간이 필요하고,  해커가 쿠키(세션ID)를 재사용 한더라도 서버는 사용자를 정확히 식별하지 못한다.JWT (Json Web Token)모바일 서비스가 급증하면서 대표적으로 사용하고 있는 인증 방식이다. 우리나라에선 카카오의 거의 모든 서비스가 JWT(토큰 기반 인증 방식)를 사용하고 있다. 앞서 설명한 세션/쿠키 방식과 비슷하게 사용자는 Access Token(JWT 토큰)을 HTTP 헤더에 담아 서버에 요청을 보낸다.왼쪽에 Encoded에 표시된 값이 JWT 토큰 값이고 오른쪽에 표시된 값이 JWT 토큰을 해석한 값이다. JWT 토큰은 3개 영역으로 나뉘는데,  Header : 토큰에 사용될 암호화 방식(alg)과 타입(typ),  Payload : 서버에 보낼 데이터 (사용자 ID, 이름, 유효기간등),  Verify Signature : Base64 방식으로 인코딩한 Header, Payload 그리고 Secret key를 더해 서명Encoded Header + “.” + Encoded Payload + “.” + Verify SignatureHeader와 Payload는 16진수로 인코딩만 되기 때문에 노출될 경우 누구나 디코딩하여 확인할 수 있어 쉽게 사용자의 중요한 정보가 노출될 수 있다. 하지만 Verify Signature 는 Secret key로 암호화 되어 있기 때문에 Secret key를 알지 못하면 복호화 할 수 없다.지금까지 알아본 내용을 바탕으로 예상되는 해킹 시나리오!!해커 존은 자신의 JWT 토큰 값을 이용해 샤론의 정보를 훔쳐보고 싶어졌다. Payload에 있던 자신의 name을 샤론의 이름으로 바꿔 다시 인코딩하고 JWT 토큰을 서버로 보냈다. 성공했을까?실패다. 서버는 암호화된 Verify Signature를 검사하는데 최초에 John Wick이라는 이름이 담긴 Payload로 암호화를 했기 때문에 이름을 Charon으로 바꾼 JWT 토큰은 유효성 검사에 실패하게 되어 유효하지 않은 토큰으로 간주된다. JWT가 어떻게 인증에 사용되는지 알아보자.  사용자는 서버에 인증 요청(+계정 정보(ID/PW))을 보낸다.  서버는 계정 정보를 회원 DB에서 확인하고 고유한 값(ID)과 사용자 정보를 Payload에 담는다.  토큰의 유효기간을 설정해 Secret key로 암호화 하여 Access Token(JWT) 발급  발급한 Access Token(JWT)을 사용자에게 전달하고, 사용자는 JWT를 쿠키에 저장한다.  사용자는 발급받은 JWT를 요청 헤더(쿠키)에 담아 서비스 요청 시 본인이 누구인지 알린다.  서버는 JWT를 복호화하여 조작 여부, 유효기간을 확인한다.  검증이 완료되면 Payload를 디코딩하여 사용자의 권한에 맞는 서비스를 제공한다.JWT는 세션/쿠키 방식과 마찬가지로 HTTP 헤더에 인증정보(세션ID/토큰)를 담아 요청한다는 점에서 동일하지만, 세션 저장소를 필요로 하지 않는다는 점에서 차이가 있다.  JWT는 토큰 발급 후 검증만 하면 되기 때문에 추가 저장소가 필요없다.  추가 저장소가 없다는 것은 Stateless 서버를 만드는데 큰 장점을 갖는다.  세션과 같이 상태 정보를 저장하고 있지 않기 때문에 서버를 확장하거나 유지/보수하는데 유리하다.  JWT는 한 번 발급되면 유효기간까지 계속 사용이 가능하다.  쿠키가 노출되어 다른 사람에 의해 악의적으로 재사용된다면 막을 수 있는 방법이 없다.  Payload는 따로 암호화되지 않기 때문에 저장할 수 있는 정보가 제한적이다.  JWT는 길이가 길어 요청이 많아질수록 서버의 자원낭비가 발생한다.Access Token + Refresh TokenJWT의 문제점을 보완한 Access Token + Refresh Token 방식에 대해 알아보자.Access Token(JWT)방식의 가장 큰 문제점은 노출되었을 경우 유효기간이 종료될 때까지 막을 수 있는 방법이 없다는 것이었다. 유효기간을 짧게 하면 사용자가 로그인을 자주해야하는 불편함이 있고, 늘리면 늘릴수록 보안에 취약하게 된다.Refresh Token은 Access Token의 유효기간을 짧게 하면서 사용자 편의성과 보안성을 동시에 높인 방법이다. Refresh Token 역시 Access Token 과 마찬가지로 유효기간이 있는 하나의 토큰이다. Access Token과 Refresh Token이 어떻게 상호작용하는지 간단한 예를 들어보자.Refresh Token의 유효기간은 2주, Access Token의 유효기간은 30분이라고 해보자. 사용자는 로그인 후 30분동안 토큰의 갱신 없이 자유롭게 서비스를 이용한다. 30분이 지나면 Access Token은 만료된다. 그리고 Refresh Token이 새로운 Access Token을 발급해준다.  사용자는 서버에 인증 요청(+계정 정보(ID/PW))을 보낸다.  서버는 계정 정보를 회원 DB에서 확인한다.  서버는 Access Token과 Refresh Token을 발급한다. 서버는 회원DB에 Refresh Token 저장.  사용자에게 Access Token과 Refresh Token을 전달한다. 사용자도 RefreshToken을 저장.  Access Token(JWT)을 요청 헤더(쿠키)에 담아 서비스 요청.  서버가 Access Token을 검증.  서버는 요청한 정보에 맞는 서비스 제공.  Access Token이 만료됨.  이전과 동일하게 Access Token을 헤더(쿠키)에 담아 서비스 요청.  서버는 Access Token이 만료됨을 확인.  서버는 사용자에게 Access Token이 만료되어 권한이 없음을 알림.  사용자는 저장하고 있던 Refresh Token과 만료된 Access Token을 서버에 전달.  서버는 Access Token 검증, Refresh Token 검증 후 새로운 Access Token 발급.  새로운 Access Token을 전달.  Access Token(JWT)만 사용했을 때보다 훨씬 안전하지만,  구현이 복잡하고 Access Token이 만료될 때마다 요청이 많아 서버의 자원 낭비가 심하다.OAuth 2.0최근 거의 모든 웹/모바일 서비스가 제공하고 있는 인증 방법이다. 2007년 OAuth 1.0이 발표되고, 취약점이 나타난 이후 2012년부터 OAuth 2.0을 사용하고 있다.OAuth 2.0 의 특징은 Access Token의 유효기간이 생겼고, 모바일에서 사용 가능하며, HTTPS를 사용한다.용어정리  Resource Owner : 일반 사용자, 사람이 사용하는 브라우저나 모바일 기기로 보면 편하다.  Client : 웹 애플리케이션 서버  Authorization Server : 권한 관리 서버, Access Token과 Refresh Token을 (재)발급  Resource Server : OAuth 2.0 서버, 서비스를 제공하는 회사의 자원을 관리하는 서버          Resource Owner는 Client에 인증 요청.      Client는 Resource Owner가 인증할 수 있는 수단(e.g. Google 로그인 페이지)을 제공.      Resource Owner는 인증을 마치고 Authorization Grant(권한증서)를 url에 담아 Client에게 전달.      Client는 Authorization Grant를 Authorization Server에 전달.Authorization Server는 Authorization Grant를 확인 후 Access Token, Refresh Token, 사용자 정보(ID 등)를 발급.      Client는 Access Token과 Refresh Token을 DB에 저장하고, Access Token과 Refresh Token을 Resource Owner에게 전달.      Resource Owner는 Access Token을 헤더에 담아 Resource Server에 자원 요청.      Resource Server는 Access Token이 유요한지 확인 후 Client에게 자원 전달.      Token 검증 과정  Access Token이 만료되면, Client는 Authorization Server에 Refresh Token을 보내 Access Token을 재발급.  Authorization Server는 Resource Server에 자원 요청.  Refresh Token이 만료되면 Resource Owner는 다시 로그인.물론, OAuth 2.0에도 취약점이 존재한다. CSRF 공격이나 Covert Redirect 공격에 취약할 수 있다. 그리고 구현이 매우 복잡한데, 제대로 구현한다면 이 방법만큼 안전하고 편리한 인증방법이 또 있을까?PDF 다운로드"
  },
  
  {
    "title": "Frida for iOS",
    "url": "/posts/Frida-for-iOS/",
    "categories": "Security, Mobile",
    "tags": "ios, frida",
    "date": "2018-12-27 00:00:00 +0900",
    





    
    "snippet": "2018년 12월 iOS 버전이 12.1.2까지 배포되었다. 반면 iOS Jailbreak(탈옥)툴은 iOS 11.4 Beta3 까지 지원된다.(iOS 11.4 Beta3 다운그레이드 불가) 현재 iOS 11.4.1 버전에 대한 Exploit을 Ian Beer가 가지고 있는 것으로 알려져 있고 Electra를 통해 배포될 것으로 예상하고 있지만 언제 ...",
    "content": "2018년 12월 iOS 버전이 12.1.2까지 배포되었다. 반면 iOS Jailbreak(탈옥)툴은 iOS 11.4 Beta3 까지 지원된다.(iOS 11.4 Beta3 다운그레이드 불가) 현재 iOS 11.4.1 버전에 대한 Exploit을 Ian Beer가 가지고 있는 것으로 알려져 있고 Electra를 통해 배포될 것으로 예상하고 있지만 언제 배포될지 확실하지 않다.새로운 버전의 iOS가 배포되면 이전 버전 iOS를 위한 Jailbreak 툴이 배포되었던 흐름에 맞추어 볼 때, 최근 iOS Jailbreak가 쉽지 않아졌음을 짐작할 수 있다. 이 문서에서 설명하는 Frida는 Jailbreak 여부와 상관없이 iOS 애플리케이션을 분석하는데 사용할 수 있지만, 제한없는 사용을 위해 탈옥된 아이폰을 대상으로 한다.따라서 iOS 11.4 Beta3 이하 버전의 탈옥된 아이폰을 사용하는 것이 좋다. 탈온된 아이폰에서 Frida를 이용한 애플리케이션(이하 앱) 분석 및 공격 방법을 알아보자.Jailbreak iPhoneiOS 버전에 따라 다양한 Jailbreak 툴을 사용할 수 있다. 가장 최신 버전의 iOS를 위한 Jailbreak 툴을 소개하자면, Coolstar의 Electra가 있다. 11.2 부터 11.4 Beta3 까지 지원한다. 가지고 있는 아이폰의 iOS 버전을 확인하고 그에 맞는 Jailbreak 툴을 이용하면 된다. 자신의 아이폰이 iOS 11.4.1 이상 버전이라면 다른 아이폰을 구해보도록 하자.CydiaCydia는 탈옥된 iOS 디바이스를 위한 앱 스토어다. 애플의 앱 스토어에서 설치할 수 없는 앱 또는 기능 개선을 위한 트윅(tweak)을 설치할 수 있다. iOS 앱 해킹을 위해 기본적으로 BigBoss Recommended Tools, OpenSSH, Frida와 같은 트윅을 설치한다. Jailbreak 툴을 사용해 탈옥을 하면 보통 자동으로 설치 되지만 간혹 함께 설치 되지 않는 경우도 있어 직접 설치해야 할 때도 있다. (Cydia를 만든 Jay Freeman이 곧 Cydia를 폐쇄 한다고 한다.)Install Frida Server on iPhoneCydia에서 Frida를 설치해보자. frida.re에서 간단한 설치 방법을 확인할 수 있다.Sources(소스) 탭 -&gt; Edit(편집) -&gt; Add(추가) -&gt; https://build.frida.re그리고 나면 Search(검색) 탭에서 Frida를 찾을 수 있다. 설치하면 된다.현재 버전은 12.2.27이다. 이어서 설치할 Frida CLI Tools의 Major 버전이 일치해야 제대로 동작한다. Frida tools의 버전은 12.2.x 여야 한다.Install Frida’s CLI Tools on your MacFrida 서버에 스크립트를 전달하기 위해 Python을 사용한다. (Command 1) 이 때 사용할 Python용 Frida 라이브러리를 설치한다. Python 3 를 사용하여 전달하기로 한다.(Command 2)아이폰에 설치된 Frida 서버와 통신하고 간단한 명령을 전달하기위해 사용자의 컴퓨터에 Frida 툴(Frida’s CLI tools)을 설치해야 한다. 설치를 위해 Python이 설치되어 있어야 하는데, Python 2.7을 사용하는 것을 추천한다. (Command 3,4)Commands:  brew install python3 (Python 3 설치(brew for Mac))  pip3 install frida (Python3 용 Frida 라이브러리 설치)  sudo easy_install pip (Python 2.7 패키지 관리자 설치 - 기본적으로 설치되어있지 않다.)  sudo -H pip install frida-tools (Python 2.7 버전의 Frida-tools 설치)          pip3로 설치하지 않는 이유는 pip3의 frida-tools는 인코딩 버그가 있어 한글이 제대로 표시되지 않는다.      Module six 관련 에러가 날 경우 sudo -H pip install frida-tools --ignore-installed six 로 설치      Test Frida여기까지 Frida를 실행할 준비를 마쳤다. 아이폰을 컴퓨터에 연결하고 frida-ps -U 명령을 실행해보자.위 명령이 정상적으로 실행되었다면 현재 아이폰에서 동작중인 프로세스의 목록을 볼 수 있을 것이다. 앞으로 자주 사용하게 될 명령 frida-ps -Uai 도 실행해보자. 프로세스의 Identifier를 출력해준다. 주로 앱의 Identifier를 이용해 앱에 접근해 공격을 실행할 것이다.Sandbox아이폰은 보안을 위해 Sandbox라는 개념을 가지고 있다. Sandbox는 커널 수준에서 시행되는 접근 제어 기술이다. 앱을 실행할 때 격리된 공간(Sandbox)을 제공하고 그곳을 벗어나 허용되지 않은 작업을 하지 못하도록 방지하는 기술이다.운영체제별로 다양한 형태로 Sandbox를 구현하고 있는데, 아이폰의 경우 아래 그림과 같이 구현되어 있다.Cydia에서 OpenSSH를 설치하고 root 계정으로 접속해보면 /var/containers/Bundle/Application에서 앱 리스트를 확인할 수 있다. 위 그림에서 총 6개의 앱들을 확인할 수 있는데, 예측하기 힘든 난수로 된 문자열의 폴더명을 가지고 있다. 앱이 설치되기 전까지 디렉터리의 이름을 알 수 없기 때문에 다른 앱이나 리소스가 접근할 수 없다.Clutch and Get a binary from Application SandboxFrida 스크립트를 작성하기 전에 앱 분석을 먼저 해야 한다. 앱이 어떻게 구현되어 있는지 알고 공격하고자 하는 위치를 정확히 알아야 그에 맞는 스크립트를 작성할 수 있다. 아이폰의 실행파일은 앞서 설명한 앱의 샌드박스에 들어있다. 샌드박스 안을 살펴보면 MyApp.app, Documents, Library 등의 폴더와 파일들이 존재하는데, 이 중에 MyApp.app 패키지 폴더에 실행파일이 들어있다. scp 또는 iFunbox 등을 이용해 다운로드 받으면 된다. 아래 예시에선 exchange라는 앱의 실행파일을 다운로드 받았다.앱 스토어에 배포된 앱을 분석할 경우, 실행파일이 암호화되어 있기 때문에 다운로드 받더라도 분석할 수 없다. 이 경우 Clutch를 이용해 복호화할 수 있다.Clutch 를 이용해 앱을 복호화1하면 분홍색으로 복호화된 실행파일의 경로를 표시해준다. 위 예시의 경우 /var/tmp/clutch/8595636C-4456-4061-9E70-7F4CB5E21995 에 있는 실행파일을 가져오면 된다.Open the Binary with IDA아이폰에서 다운로드한 실행파일을 IDA 를 이용해 열어보자. 위 그림과 같이 IDA는 함수의 목록을 보여주는 Functions 부분과 함수의 내용을 표시해주는 Disassemble View 부분으로 나뉜다. Functions 에서 분석하고자 하는 대상의 함수를 먼저 찾고, Disassemble View 에서 함수의 내용을 확인한다. 함수를 분석하기 위해서는 Objective C 의 기본 문법2에 대한 이해를 필요하다.Objective C - Basic #1. FunctionsIDA의 Functions에서 확인할 수 있는 Objective C 함수의 특징을 살펴보자.함수의 모양을 살펴보면 총 3가지 형태의 함수가 있다.  -[exchange.AppDelegate application:didFinishLaunch:] : Objective C의 기본적인 함수의 형태다. (-)로 시작하는 함수는 인스턴스 함수를 의미하며 (+)로 시작하는 함수는 클래스 함수다. [Object Method:Parameter ..] 로 구성되어 있다. 오른쪽 그림과 같이 somePerson 객체에 존재하는 sayHello 함수를 호출하면 XYZPerson 클래스에 있는 sayHello 함수가 호출되는 방식이다. sayHello 함수에서 다시 함수가 호출되는데, 여기서 사용된 self는 C++의 this 포인터와 같은 역할을 한다. 자기 자신의 saySomething 함수를 호출한다. 콜론(:)을 구분자로 파라미터를 전달할 수 있다.  sub_100016928 : 심볼(Symbol) 정보가 없는 함수다. 함수의 주소값을 이용해 함수에 접근할 수 있다. Objective C 컴파일러에 의한 코드 최적화 과정에서 코드의 일부가 별도의 함수로 분리된 경우도 이에 속한다. 이 함수와 연관된 Caller 함수는 가까운 주소에 위치하고 있다.  nullsub_() : 프로그램에 실제로 존재하는 코드이긴 하나, 최종 버전에는 존재하지 않는 호출이다. 함수의 값이 0으로 설정된 경우 return 과 같은 역할을 한다.Objective C - Basic #2. objc_msgSendMessage Send는 Objective C를 대표하는 가장 중요한 개념이다. 앞서 살펴본 바와 같이 대괄호 [ ] 사이에 쓰여지는 코드에 의해 Objective C 메시지를 생성한다. Objective C 코드로 [receiver message] 와 같이 메시지를 보낸다고 하면 컴파일러는 objc_msgSend(receiver, selector)로 코드를 바꾼다. 인자가 있을 경우 objc_msgSend(receiver, selector, arg1, arg2, ..) 로 바꾼다. Objective C가 receiver에게 message를 전달하면 대상 객체(receiver)는 메시지(message)가 누구로부터 왔는지, 클래시 캐시(Classh cache)와 클래스 디스패치 테이블(class dispatch table)을 검색하여 어떤 함수를 실행할지 등의 결정을 한다.예를 들어, 다음 코드는​[self printMessageWithString:@\"Hello world!\"];​컴파일되면 실제로 아래와 같은 코드로 변환되고,​objc_msgSend(self, @selector(printMessageWithString:), @\"Hello world\");​대상 객체의 isa 포인터3를 이용하여 해당 메시지에 대한 셀렉터의 응답여부를 확인하고 실행한다. 실제로 objc_msgSend 함수는 아무값도 리턴하지 않지만, 이 메시지에 의해 실행되는 함수가 결과를 리턴하기 때문에 objc_msgSend가 리턴하는 것처럼 보인다.Trace FunctionsFrida는 frida-tools에 포함된 명령어를 이용하는 방법과 Frida API를 활용한 스크립트 인젝션(Injection) 두가지 방법으로 사용할 수 있다. 좀 더 자유로운 Frida 사용을 위해 Frida API를 이용해 앱을 후킹(Hooking) 해보자. iOS 앱의 기본이자 앱의 시작인 AppDelegate 클래스를 추적할 것이다. 사용한 스크립트는 0xdea/frida-scripts를 참조하여 작성하였다.스크립트를 다운로드 받아 raptor_frida_ios_trace.js(이하 trace.js) 파일을 열고 코드 마지막 부분에 아래와 같이 trace(“-[exchange.AppDelegate *]”) 를 작성하여 저장하여 아래 명령을 실행해보자.$ frida -U -f com.bitxflow.exchange -l ./raptor_frida_ios_trace.js --no-pause옵션을 간단히 살펴보면 -U 옵션은 USB 연결, -F 옵션은 실행(spawn)할 앱의 패키지 명, -L 옵션은 불러올 스크립트 파일명, 그리고 –no-pause는 앱을 시작시킨 후 멈춤없이 진행하는 것을 뜻한다.실행된 결과를 보면 exchange.AppDelegate 클래스와 관련된 모든 함수들의 실행 결과를 화면에 출력해준다. 그리고 어떤 함수(Caller)가 호출하였는지, 인자(parameter)는 무엇인지, 그리고 결과값(retval)은 무엇인지 보여준다. 앱이 실행되는 과정에서 어떤 함수들이 호출되는지 살펴볼 때 사용할 수 있다.Debug FunctionDebug라는 제목을 쓰긴 했지만 Frida는 후킹(Hooking)을 이용하기 때문에 정확한 의미에서 Debug는 아니다. 하지만 거시적 관점에서 앱 해킹을 할 때 Debugging을 통해 함수의 입/출력값 조작, 함수의 동작 변경을 수행하고 있기 때문에 Debug라고 해보자. 호출되는 함수들 중에 특정 함수를 살펴보고자 할 땐 다음과 같이 Frida를 사용할 수 있다. 예제 코드는 raptor_frida_ios_autoIntercept.js(이하 autoIntercept.js)를 사용하였다.앱의 동작 과정 중 Google Firebase OAuth 인증의 일부분을 확인해보았다. FIRAuth 클래스에 있는 canHandleURL 함수의 인자(arg)값과 리턴(retval)값을 확인해보았는데, 인자값으로 Google에 사용자 정보를 요청하는 것으로 보이는 URL을 전달받고, 아무것도 리턴하지 않았다. Interceptor.attach(oldImpl.implementation, {}) 에 있는 onEnter: function(args) {} 과 onLeave: function(retval) {} 함수를 고쳐 함수의 인자값과 리턴값을 변경할 수 있다.Convert IDA address to memory address함수의 심볼정보가 없는 함수(예. sub_100016928)의 경우 앞서 사용한 스크립트를 이용해 공격할 수가 없다. IDA에서 확인한 함수의 주소값을 이용해 직접 함수를 후킹해야 한다. 아래 memAddress 함수를 이용해 IDA에서 확인한 주소로 함수가 앱에서 동작할 때의 주소를 가져올 수 있다.IDA 에서 확인할 수 있는 sub_100016928 함수는 AppDelegate 함수에서 호출하고 있는 함수다. 별도의 심볼정보가 없기때문에 함수 명을 이용하지 않고, memAddress 함수를 만들어서 함수의 주소를 가져왔다. memAddress 함수의 세 번째 인자에 IDA 에서 확인한 함수의 주소값을 넣어주는데, 0x100016928이 아닌 0x16928인 이유는 IDA가 실행파일 분석 시 사용한 베이스 주소 0x100000000 를 제외한 값이다.Frida CodeShare보안을 위해 앱들이 가지고 있는 공통적인 기능(예를 들면, SSL Pinning, Anti Jailbreak 등)들이 있다. 이 기능들은 앱 점검을 위해 반드시 우회해야 하는 기능들이다. 이 기능들의 구현은 거의 비슷한 방법으로 이루어지기 때문에 Frida 스크립트를 이용해 우회 한다면 거의 동일한 코드가 작성될 것이다. 이 번거로움을 피하기 위해 Frida CodeShare Project가 만들어졌다. Frida CodeShare Project는 세계 각국의 개발자들로 구성되어 있으며, 다양한 아이디어를 공유하기 위해 만들어졌다. 여기서 우리는 앱의 다양한 보안 기능을 우회하거나 조작할 수 있다.대표적으로 ios-ssl-bypass 코드가 있다. SSL Pinning 기술을 통해 서버와 통신하는 내용을 안전하게 보호할 수 있지만, 이 코드를 사용하면 손쉽게 우회가 가능하다. 별도의 코드 작성 없이 아래 명령$ frida —codeshare dki/ios10-ssl-bypass -f &lt;app identifier&gt;을 실행하면 보안 기능이 바로 우회된다. 다양한 코드가 공유되어 있으니, 검색해보자.To bring this session to an endFrida는 사용하는 방법에 따라 무한한 잠재력을 가지고 있고, 계속해서 기능이 추가되고 있다. 최신 버전의 Frida는 커널도 다룰 수 있다. 아이폰뿐만 아니라 안드로이드, 일반 PC, Mac OS 에서 동작하는 앱도 후킹이 가능하다. 갈고 닦아 내 것으로 만들자!!PDF 다운로드  1 clutch를 이용해 복호화 하면 실행파일과 함께 사용된 라이브러리도 함께 복호화된다. clutch에 표시된 경로에서 실행파일을 찾아보자.  2 swift로 작성된 앱도 빌드 과정에서 Objective C로 변환되기 때문에 최종적으로 Objective C 문법을 이해하고 있어야 한다.  3 Objective C의 모든 객체는 isa라는 클래스 타입 맴버 변수를 가지고 있다. 다른 클래스를 가리키거나 자기 자신 클래스 객체를 가리키는데 쓰인다."
  },
  
  {
    "title": "Node JS Serialization Vulnerability",
    "url": "/posts/NodeJSRCE/",
    "categories": "Security, Web",
    "tags": "NodeJS, web, vulnerability",
    "date": "2018-05-24 00:00:00 +0900",
    





    
    "snippet": "SaaS와 MBaaS에 대해 다룬 적이 있다. 글로벌 IT 기업들이 제공하고 있는 가장 최신의 서비스 플랫폼이며, 현재 가장 많이 사용되고 있는 플랫폼이기도 하다. 하지만 여기서 그치지 않고 서비스 플랫폼은 서버리스(Serverless) 형태로 발전하고 있다. 말 그대로 서버가 없음을 의미하지만 사실 서버는 존재하고, 개발자들은 애플리케이션의 기능(F...",
    "content": "SaaS와 MBaaS에 대해 다룬 적이 있다. 글로벌 IT 기업들이 제공하고 있는 가장 최신의 서비스 플랫폼이며, 현재 가장 많이 사용되고 있는 플랫폼이기도 하다. 하지만 여기서 그치지 않고 서비스 플랫폼은 서버리스(Serverless) 형태로 발전하고 있다. 말 그대로 서버가 없음을 의미하지만 사실 서버는 존재하고, 개발자들은 애플리케이션의 기능(Functions)에만 집중하는 형태다. FaaS(Functions as a Service)1로 불리는 이 서비스는 Google Cloud Functions가 대표적이다. 그리고 여기서 사용하는 대표적인 언어가 Javascript로 만들어진 Node.js다.Node JS 실행 환경사실 Javascript 런타임(프로그래밍 언어가 구동되는 환경)은 브라우저에만 있었다. 하지만 이 한계를 극복하고 Node.js가 만들어졌다. Node.js는 REPL(Read, Eval, Print, Loop)을 통해 런타임을 제공한다. 윈도우의 REPL커맨드 창이나, 리눅스의 터미널 환경처럼 사용자가 명령을 입력하면 시스템은 명령을 읽고(Read), 명령을 처리(Eval)한 후, 결과를 출력(Print)한다. 그리고 사용자가 Ctrl + C를 눌러 종료할 때까지 이 과정을 반복(Loop)한다. 또는 Javascript 파일을 Node.js 에서 제공하는 Javascript 런타임을 이용해 실행시킬 수 있다. 애플리케이션 서버를 제작할 때 보통 이 방식을 이용한다.Serialization and IIFESerialization(직렬화)은 객체를 직렬화하여 전송 가능한 형태로 만드는 것을 의미한다. 객체의 데이터를 연속적인 데이터로 변환하여 Stream을 통해 전달한다.IIFE(Immediately Invoked Function Expressions)는 즉시 함수 호출 표현식의 줄임말이다. 괄호가 이름이 없는 함수를 감싸며 함수가 선언된다. 선언과 동시에 실행되며, 이 함수는 전역 스코프(scope, 영역)에 선언되지 않기 때문에 나중에 다시 호출 할 수 없다. IIFE를 사용하는 이유는 전역 스코프에 함수 또는 변수를 선언하는 것을 피하기 위해서다. 그리고 Javascript의 클로저(Closure)를 쉽게 제어하기 위해 사용한다. 자세한 내용은 미루고 문제점에 대해 알아보자.(function() {    // Do fun stuff    })()Node.js에 있는 ‘node-serialize’ 모듈의 unserialize 함수는 직렬화된 임의의 코드 데이터를 전달받게 되면 deSerialization(역직렬화)하면서 실행 가능한 Javascript 코드로 바꿔준다. 즉, unserialize 함수를 사용하는 서버에 IIFE를 이용해 임의의 코드를 전달하면 버그로 인해 공격자의 코드가 서버에서 실행될 수 있다.Exploitable Server서버는 3000번 포트로 서비스되고 있다. 4번째 줄에서 ‘node-serialize’ 모듈을 serialize 라는 변수로 사용한다. 서비스의 동작 과정을 살펴보면:  사용자의 접속 요청에 담긴 쿠키 정보 중 profile에 담긴 데이터를 base64로 Decode  unserialize 함수로 역직렬화.  역직렬화로 확인한 전달받은 데이터 중 username 의 값을 화면에 표시여기서 문제가 발생하는 부분은 2번이다. unserialize 함수가 실행될 때 전달받은 인자 str이 IIFE함수일 경우 이 인자(함수)를 실행한다.Exploit Test, 공격 테스트공격 코드를 만들 때 가장 쉽게 접근할 수 있는 방법은 서버의 취약한 코드를 그대로 사용해 보는 것이다. 아래 코드와 같이 ‘node-serialize’ 모듈의 serialize 함수를 이용해 공격 코드를 만들어 보자.변수 y에 담긴 Javascript 함수는 서버의 루트(/) 디렉터리의 파일 목록을 화면에 표시해주는 코드다. 7번째 줄에서 이 코드(y)가 serialize 함수에 전달되어 serialize 된 코드가 아래와 같이 화면에 표시된다.Javascript 코드가 serialize 되긴 했지만, 실행이 되지 않았다. 이유는 Javascript 함수를 IIFE 로 만들지 않았기 때문이다. IIFE로 만들어야 선언과 동시에 실행시킬 수 있다.위 Exploit Test Code #1에 있는 Javascript 함수 끝에 괄호를 추가해 IIFE 함수로 선언한다.Serialize는 실패했지만, Javascript IIFE 코드는 잘 실행되었다. 최종적으로는 서버의 unserialize 함수를 공격하는 것이 목표이므로, unserialize 함수도 Javascript IIFE 함수를 잘 실행시키는지 확인한다.앞서 Exploit Test Code #1의 결과로 만들어진 serialize된 Javascript 코드의 끝에 괄호를 추가해 IIFE Javascript 함수로 선언 뒤 unserialize 함수의 인자로 전달했다. 아래와 같이 잘 실행된다.Reverse Shell Remote Code Execution이제 서버에 직접 공격을 해보도록 하자. 공격은 다음과 같이 구성했다.서버에 보낼 공격 코드는 Reserve Shell2 코드다. 공격에 성공하면 서버는 공격자의 IP로 미리 열어둔 1337번 포트에 서버의 쉘을 전달한다. 공격자는 서버의 쉘을 획득할 수 있다. 공격 코드는 nodejsshell.py를 이용해 다음과 같이 만든다. 공격자의 IP는 192.168.0.3이고, Port는 1337번이다.결과로 나온 Encoding 값을 보면 eval 함수와 String.fromCharCode 함수로 구성되어 있다. String.fromCharCode함수는 숫자를 문자로 변환해주고, eval 함수는 인자로 받은 Javascript 소스코드를 동적으로 실행시킨다.서버에서 실행시킬 공격 코드를 만들었으니, 서버에 전달해보자. 서버의 동작 과정을 다시 떠올려보면, 서버는 먼저 사용자의 접속 요청에 담긴 쿠키 정보 중 profile에 담긴 데이터를 base64로 디코드 한다. 그리고 이 값을 unserialize 한다. 따라서 우리는 공격 코드를 base64로 인코딩해서 전달해야 한다. 뿐만 아니라, 공격 코드를 IIFE 함수로 선언해야 한다. 그래야 Result #2와 같이 전달과 동시에 코드가 실행된다.Burp Suite의 Decoder 탭으로 이동해서 앞서 만든 공격 코드에 괄호를 추가해 base64 인코딩된 페이로드(Payload)를 만들어보자. 그리고 쿠키 헤더에 인코딩된 공격 코드를 담아 웹서버로 보낸다.아래와 같이 공격을 시도하면 공격자가 열어 놓은 1337번 포트에 서버의 쉘이 연결되는 것을 확인할 수 있다.성공적으로 서버의 쉘과 루트(root) 권한을 획득했다.보통 Serialize 버그로 인한 취약점은 JAVA 에서 많이 발견되는데, Node.js에서 발견된 것은 이례적인 일이었다. CVE-2017-5941로 찾을 수 있는 이 공격은 node-serialize 0.0.4 버전에서 발생했으며, 아직 패치되지 않은 상태다.Node.js로 서버를 구현할 때 이 모듈을 사용한 serialize / unserialize 는 지양해야 한다. Serialize-to-js 모듈에서도 비슷한 버그(CVE-2017-5954)가 있는 것으로 알려져 있다.PDF 다운로드  1 서버 시스템에 대해 신경쓰지 않아도 된다는 점에서 PaaS와 헷갈릴 수 있는데, PaaS는 서비스가 24시간 동작하는 반면, FaaS는 특정 이벤트가 발생했을 때에만 실행되며, 작업을 마치면 종료되는 차이점이 있다.  2 Shell(쉘) : 서버나 휴대폰같은 장치에서 명령을 실행하기 위해 사용되는 프로그램.Reverse Shell(역방향 쉘) : 공격자가 특정 포트를 열어두면 공격 대상은 공격자에게 접속해 쉘을 제공."
  },
  
  {
    "title": "Make user certificates available on Android 7.0",
    "url": "/posts/UserCertOnAndroid/",
    "categories": "Security, Mobile",
    "tags": "android",
    "date": "2018-05-08 00:00:00 +0900",
    





    
    "snippet": "2016년 8월 안드로이드 7.0 누가(Nougat) 버전이 배포되었다. 새로운 메모리 보호 기능이 추가되었고, APK 서명 스킴(Scheme) v2가 추가되었다. 네트워크 트래픽 보안을 위해 사용자가 직접 설치한 인증서는 더 이상 신뢰하지 않는다. API 레벨이 24 이상인 애플리케이션의 경우 해당된다.앱 보안을 위한 개선사항으로 볼 수 있겠지만, ...",
    "content": "2016년 8월 안드로이드 7.0 누가(Nougat) 버전이 배포되었다. 새로운 메모리 보호 기능이 추가되었고, APK 서명 스킴(Scheme) v2가 추가되었다. 네트워크 트래픽 보안을 위해 사용자가 직접 설치한 인증서는 더 이상 신뢰하지 않는다. API 레벨이 24 이상인 애플리케이션의 경우 해당된다.앱 보안을 위한 개선사항으로 볼 수 있겠지만, 모바일 앱 취약점 점검을 위해 Burp Suite 같은 프록시 도구를 사용하는 상황에선 문제가 된다. HTTPS 통신을 분석하기 위해 Burp Suite의 인증서(사용자 인증서)를 휴대폰에 설치하여 사용해야 하는데, 사용할 수 없기 때문이다.지난 3월 에스원에서 만든 모바일 방문객 앱의 경우에도 이와 같은 문제로 최신 안드로이드 휴대폰(버전 7.0 이상)에서는 통신 내용을 살펴볼 수 없었다. 휴대폰을 루팅(rooting)한 경우 여러가지 방법으로 이 문제를 해결할 수 있겠지만, 루팅이 어려운 상태에서 이 문제를 어떻게 해결할 수 있는지 알아보자.Network Config안드로이드 API 24 이상 버전부터 기본 네트워크 설정이 변경되었다.앱이 동작할 때 사용자(user) 인증서는 더 이상 신뢰하는 대상에 포함되어 있지 않다. 사용자 인증서를 신뢰할 수 있도록 만들어야 한다. 기본적인 아이디어는 API 23 버전까지 사용하던 네트워크 설정을 가져오는 것이다. 안드로이드 개발자 사이트를 참고하여 앱을 변조해보자.Decompileapktool을 이용해 대상 APK파일을 디컴파일한다. AndroidManifest.xml과 Smali파일들을 얻을 수 있다.apktool.bat d &lt;apk file&gt; -o &lt;directory of decompiled files&gt;Modify AndroidManifest.xml앱이 네트워크 설정 정보를 참조할 수 있도록 networkSecurityConfig 속성 설정Add res/xml/network_security_config.xmlAndroidManifest.xml에 @xml/network_security_config로 값을 지정했다. xml 폴더의 network_security_config.xml 파일을 참조하라는 의미다. 따라서 이 네트워크 설정 파일을 앱이 참조할 수 있도록 xml파일을 오른쪽 그림과 같이 생성해준다.AndroidManifest 파일에 직접 설정 파일명을 적어주지 않고 annotation으로 설정하는 이유는 앱이 빌드되는 과정에서, R.smali 파일이 annotation을 통해 필요한 리소스를 매핑하기 때문이다.Put R$xml into R.smali앱이 참조하는 리소스 목록은 다음과 같이 R.smali 파일에 annotations로 정의되어 있다. 여기에 앞서 생성한network_security_config.xml 파일과 이 파일이 들어 있는 xml 폴더를 포함시키기 위해 annotations 에 R$xml을 추가해준다.R.smali는 R$로 시작하는 smali 파일들의 부모 파일이다. R$xml은 R$xml.smali 파일을 참조하겠다는 선언으로 이해하면 된다.Create R$xml.smali이제 R.smali 파일은 R$xml.smali을 참조할 수 있다.하지만 R$xml.smali 파일은 아직 존재하지 않는다. 따라서 직접 만들어줘야 하는데, 파일을 쉽게 만들기 위해 다른 임의의 파일(R$*.xml)을 아래 경로에 복사해 만들어준다.(아래 예시에서는 R$anim.xml을 복사) 그리고 복사한 파일을 R$xml.smali로 정의하기 위해 아래 붉은색 상자처럼 내용을 바꾸어주면 된다.Modify R$xml.smali#static fields에 network_security_config의 주소를 할당해준다. network_security_config라는 리소스가 0x7f0d0000 위치에 할당된다는 의미다. 이 주소는 다른 smali 파일을 참고해 사용하지 않는 주소로 정해준다.Rebuild APK and Installapktool을 이용해서 재빌드하고 sign 과정을 거치면 완료된다.(설명 생략) 새롭게 빌드한 앱(APK)을 설치하고 Burp suite 같은 프록시 도구를 이용해 네트워크 트래픽을 확인해보면 기존과 같이 잘 분석이 되는 것을 알 수 있다.Obfuscation, 난독화모바일 앱의 변조나 분석을 막기 위해 난독화 도구를 사용하는 앱이 늘고 있다. 난독화 솔루션이 적용된 모바일 앱의 경우 apktool을 이용한 디컴파일(decompile) 시 분석이나 변조가 불가능하게 보일 수 있다. 따라서 앞에 소개한 내용을 그대로 적용하기 어려울 수 있다. 현재 삼성에서 가장 많이 사용하고 있는 방식으로 난독화된 앱(e.g. 에스원 모바일 방문객 앱)을 분석해보면 R.smali 파일을 찾을 수 없다. 이 경우 다음과 같이 진행하면 된다. 앞의 내용과 다른 부분만 설명한다.Put R$xml into App.smali난독화 솔루션이 적용된 앱은 R.smali 파일 대신 App.smali 파일이 존재한다. 이름만 바뀌었을 뿐 내용은 같기 때문에 앞에서 했던 방법과 동일하게 R$xml을 annotations에 추가한다. (xml 행을 추가하면서 앞의 항목인 MsgHandler 뒤에 쉼표(,)를 추가하는 것을 잊으면 안된다.)Modify R$xml.smali#static fields에 network_security_config의 주소를 할당 해준다. 다른 점은 별도의 주소를 할당해주지 않아도 된다는 점이다. 이 내용에서 강조하고자 하는 점은 별도의 루팅(rooting) 없이 안드로이드 API 24 버전의 인증서 관련 보안 기능을 우회할 수 있다는 점이다. 안드로이드 운영체제의 루팅이 어려워지고 있는 시점에 모바일 앱 보안점검을 위해 필요한 기술이라 할 수 있다.PDF 다운로드Thanks to Hailey@Kakao"
  },
  
  {
    "title": "Smart Contract Vulnerabilities Basic 2",
    "url": "/posts/SmartContractVulnerabilitiesBasic2/",
    "categories": "Security, Blockchain",
    "tags": "blockchain, ethereum, smartcontract",
    "date": "2018-04-09 00:00:00 +0900",
    





    
    "snippet": "5. Forcing ether to a contract솔리디티(Solidity)의 selfdestruct 함수는 두 가지 작업을 한다. 컨트랙트(Contract)에 해당하는 주소의 바이트 코드를 효과적으로 삭제하여 사용 불가능하게 만들고, 컨트랙트의 모든 자금은 지정된 주소로 보내준다. 즉, 블록체인에서 스마트 컨트랙트 코드를 제거하는 함수다. 하지만...",
    "content": "5. Forcing ether to a contract솔리디티(Solidity)의 selfdestruct 함수는 두 가지 작업을 한다. 컨트랙트(Contract)에 해당하는 주소의 바이트 코드를 효과적으로 삭제하여 사용 불가능하게 만들고, 컨트랙트의 모든 자금은 지정된 주소로 보내준다. 즉, 블록체인에서 스마트 컨트랙트 코드를 제거하는 함수다. 하지만 특별한 경우가 있다. 지정된 주소가 컨트랙트라면, 해당 컨트랙트의 fallback함수를 실행하지 않는다.Fallback Function솔리디티에서 컨트랙트는 인자(arguments), 리턴(return) 그리고 이름이 없는 함수를 하나 가지고 있다. 이 함수는 어떤 데이터나 함수 호출 없이 컨트랙트를 호출했을 때 실행된다. 그리고 이 함수가 payable 인 경우 컨트랙트는 이더(Ether)를 받을 수 있고, 컨트랙트에 이더를 보낼 경우에 이 함수가 실행된다. 이 함수를 Fallback Function(함수)이라고 부른다.컨트랙트의 함수가 해당 컨트랙트의 잔액이 일정 금액 이상인지 이하인지 확인하는 조건문이 있다면, 그 조건문은 잠재적으로 우회될 수 있다.오른쪽 코드를 보자. Fallback 함수에 있는 revert1함수로 인해, 이 컨트랙트는 이더(Ether)를 수신할 수 없다. 하지만, 이 컨트랙트를 대상으로 selfdestruct 한다면, fallback 함수는 동작하지 않는다. 결과적으로, 잔액은 0보다 큰 상태가 될 수 있고, 공격자는 onlyNonZeroBalance 함수의 require 문을 우회할 수 있게 된다.Mitigation컨트랙트의 잔고를 확인하는 것을 보호 조건으로 사용하면 안된다.6. Call to the Unknown, Dos with Unexpected revert이 취약점은 King of the Ether 스마트 컨트랙트에서 발견되었다.공격자는 안전하지 않은 컨트랙트에 충분한 양의 이더(Ether)를 보내 자신이 리더임을 주장할 수 있다. 그리고나서, 리더임을 주장하려고 하는 다른 사람의 트랜젝션은 공격자의 컨트랙트에 있는 revert 함수에 의해 취소될 수 있다.단순한 공격이긴 하지만, 이 때문에 컨트랙트엔 영구적인 서비스 거부(Denial of Service)가 발생하여 쓸모없게 된다. 폰지 사기 컨트랙트(ponzi scheme contracts) 에서 동일한 패턴을 찾아볼 수 있다.7. Short Address Attack이 공격은 Golem팀에 의해 발견되었고 다음 기사에 잘 소개되어 있다. 이 취약점으로 공격자는 transfer 기능을 악용하여 허용하는 것보다 많은 양의 ERC20 토큰을 출금할 수 있다.이 버그를 설명하기 위해 먼저 10000개의 토큰이 들어있는 지갑을 가지고 있는 거래소와 이 거래소의 지갑에 32개의 토큰을 가지고 있는 사용자가 있다고 생각해보자. 그리고 사용자의 주소는 0x12345600(주소의 끝자리가 0으로 끝난다.)이라고 가정해보자.사용자(이하 공격자)는 잔고에 있는 토큰의 양보다 더 많은 양의 토큰을 출금하려고 한다. 공격자는 거래소에 가서 토큰 출금 버튼을 누른다. 그리고 공격자의 주소에서 0을 제외한 값을 입력한다. (공격자의 주소 길이가 잘못되었음에도 불구하고 거래소는 입력값 검증을 하지 않고 거래를 진행시킨다.)그런 다음, EVM은 함수의 서명과 인자로 실행되는 트랜젝션의 입력값을 계산한다.ERC20의 transfer 함수는 transfer(address to, uint256 amount)로 다음과 같이 실행된다.The vulnerability자세히 살펴보면, 트랜젝션의 길이가 2바이트 더 짧다. 이런 경우 EVM은 트랜젝션의 마지막에 0을 채워서 다음과 같이 실행한다.이렇게 하면 거래소에 32개의 토큰만 가지고 있는 공격자는 훨씬 더 많은 양의 토큰(8192개)을 완벽하게 정상적인 트랜젝션으로 만들어 실행할 수 있다. 이 공격은 보내는 사람의 계좌(거래소의 지갑 계좌)에 충분한 양의 토큰이 있다는 사실에 기초한다.Mitigation  msg.data의 크기가 잘못되었다면 예외처리  거래소는 반드시 입력값 검증한다PLUS, CVE DetailsCVE Details에서 이더리움 관련 취약점을 검색해보면 다음과 같이 나온다.모두 2018년 1월 CVE로 등록되었고, 4월 1일 기준으로 일곱개의 권한 우회(Authentication Bypass)와 두개의 DoS 취약점이 있다. 앞서 설명한 취약점들과 조금 다른 내용이지만, 요약하자면 cpp-ethereum의 JSON-RPC를 지원하는 몇가지 API에 공격 가능한 권한 관련 취약점이 있었다.스마트 컨트랙트가 없거나 의미를 갖기 힘든 컨소티움(Consortium) 블록체인이나 프라이빗(Private) 블록체인(i.e. NexLedger) 모의해킹 시 JSON-RPC는 유심히 살펴봐야 할 부분이 될 것으로 생각된다. 잘 기억해두자.  1 공컨트랙트의 모든 상태 변화를 되돌린다. 그리고 함수를 호출한 사람(Caller)에게 이더(Ether)를 되돌려 준다."
  },
  
  {
    "title": "Smart Contract Vulnerabilities Basic 1",
    "url": "/posts/SmartContractVulnerabilitiesBasic1/",
    "categories": "Security, Blockchain",
    "tags": "blockchain, ethereum, smartcontract",
    "date": "2018-04-02 00:00:00 +0900",
    





    
    "snippet": "블록체인 기술을 이용한 시스템이 활발하게 만들어지고 있다. 자연스럽게 스마트 컨트랙트(Smart Contract)의 수요가 늘어나고 있고, 현재까지는 이더리움(Ethereum)을 이용하는 경우가 가장 많아보인다. 넥스레저(NexLedger)도 이더리움을 기반으로 하고 있다. 넥스레저 혹은 다른 이름의 블록체인 취약점 점검을 위해 이더리움 스마트 컨트랙...",
    "content": "블록체인 기술을 이용한 시스템이 활발하게 만들어지고 있다. 자연스럽게 스마트 컨트랙트(Smart Contract)의 수요가 늘어나고 있고, 현재까지는 이더리움(Ethereum)을 이용하는 경우가 가장 많아보인다. 넥스레저(NexLedger)도 이더리움을 기반으로 하고 있다. 넥스레저 혹은 다른 이름의 블록체인 취약점 점검을 위해 이더리움 스마트 컨트랙트의 기본적인 취약점과 대응방법을 알아보자.스마트 컨트랙트를 작성할 때 가장 많이 사용하는 솔리디티의 대표적인 취약점 7가지와 대응 방법에 대해 알아보자.1. Overflow and Underflow오버플로우(Overflow)는 사전적인 의미로 넘쳐 흐른다는 뜻을 가진다. 오버플로우의 종류엔 여러가지가 있는데, 이해를 돕기 위해 정수 오버플로우(Integer Overflow)로 예를 들자면, 정수형 변수가 담을 수 있는 최대값을 넘어 증가할 때 발생한다. 솔리디티는 256비트 숫자(2256-1)까지 다루고 있고, 최대값보다 1 증가한 값은 0이 된다.언더플로우(Underflow)는 반대로 unsigned(자연수 범위) 변수의 값이 0보다 작아질 때 발생하며, 0보다 작아진 변수의 값은 변수의 최대값을 갖게 된다. 두 가지 모두 위험하지만 언더플로우가 일어날 가능성이 좀 더 크다.예를 들어 토큰(Token) 10개를 가지고 있는 사용자 A는 악의적으로 11개의 토큰을 사용하려고 할 수 있다. 만약 코드에서 이 취약점을 확인하지 않는다면, 공격자는 자신이 가지고 있는 토큰(10개)보다 더 많은 토큰을 소비1할 수 있다. 그리고 공격자의 토큰은 가질 수 있는 최대한의 개수(2256-1)만큼 늘어난다.Mitigation직접 입력값 검증(Validation)을 해주면 된다. 하지만 요즘엔 OpenZeppelin의  SafeMath를 많이 사용한다.2. Visibility함수의 가시성2(Visibility)에 대해서 모르는 사람은 없을 것이다. 솔리디티에도 동일한 개념이 있다. 취약점과 관련이 있는 중요한 접근 제어자를 먼저 알아보자. Public 함수는 컨트랙트 내부의 함수, 상속된(inherited) 컨트랙트의 함수 또는 외부 사용자 등 누구나 호출할 수 있다. External 함수는 외부에서만 호출할 수 있다. 컨트랙트 내부의 다른 함수들은 이 함수를 호출할 수 없다. 2017년 7월 Visibility 취약점으로 인한 Parity Wallet 해킹으로 3천만 달러 손실오른쪽의 코드를 보면 cannotBeCalled 함수는 External 함수고, canBeCalled함수는 Public 함수다. cannotBeCalled함수는 외부 가시성(External Visibility)때문에 컨트랙트 내 다른 함수(testExternal)에 의해 호출될 수 없다. 따라서 컴파일되지 않는다. 하지만 cannotBeCalled 함수는 다른 컨트랙트에 의해 호출될 수 있다.Mitigation용도에 맞추어 Public 대신 Private 함수와 Internal 함수를 사용해야 한다. Private 함수는  오직 컨트랙트 내부에서만 호출할 수 있다. Internal 함수는 조금 덜 제한적인데, 부모로부터 상속된 컨트랙트는 이 함수를 사용할 수 있다. 외부 컨트랙트에서 호출할 일이 없다면, Private 또는 Internal 함수를 사용하는 것이 좋다.3. Delegatecall솔리디티는 메시지 호출3(Message Call)을 통해 컨트랙트를 제어한다. Delegatecall는 그 중 하나로, 다른점은 함수를 호출하고 있는 컨트랙트의 컨텍스트(Context)에서 대상 주소의 코드가 실행된다는 점과 msg.sender와 msg.value의 값이 바뀌지 않는다는 점이다. 컨트랙트가 런타임(runtime)에 다른 주소의 코드를 동적으로 불러올 수 있음을 의미한다. 스토리지, 현재 주소 그리고 잔액은 함수를 호출하는 컨트랙트에서 가져오지만, 코드는 호출되고 있는 주소에서 가져온다.코드 인젝션(Code Injection)과 비슷한 개념이라 생각하면 조금 쉬울 수 있다.더 나은 이해를 위해 직접 솔리디티로 스마트 컨트랙트를 구현해보는 것이 가장 좋다.DelegateCall 함수는 라이브러리를 구현하고 코드를 모듈화(modularization)하기 위한 것이기 때문에 매우 유용하다. 하지만 근본적으로, 누구나 원하는 코드를 컨트랙트에서 실행시킬 수 있기때문에 문제가 될 수 있다.다음 코드를 보자. 공격자는 Delegate 컨트랙트의 함수 pwn을 호출할 수 있는데, 이 컨트랙트는 Delegation 컨트랙트에 속해 있기 때문에 이 컨트랙트의 소유권을 주장할 수 있다.Parity wallet 해킹은 안전하지 않은 visibility와 비정상적인 데이터에 대한 delegatecall 이 모두 포함되어 있었다. Delegatecall로 구현된 취약한 컨트랙트의 함수와 소유권을 수정할 수 있는 다른 컨트랙트가 공개되어 있었다. 공격자는 msg.data 필드를 작성해 취약한 함수를 호출할 수 있었다.msg.data 필드에 포함될 내용은 호출하고자 하는 함수의 서명이다. 여기서 서명은 함수 프로토타입의 SHA3 해시 값의 처음 8 바이트를 의미한다.4. Re-entrancy, DAO 해킹솔리디티의 call 함수는 value와 함께 호출될 때, _amount 만큼 msg.sender에게 이더(Ether)와 가스4(gas)를 전달한다. 다음 코드 스니펫(snippet)에선, sender의 잔액을 실제로 줄이기 위해 함수가 호출된다.간단히 말하자면, 내가 내 은행 계좌에 있는 돈의 출금을 요청한 상태에서, 은행원이 내 계좌의 잔고를 줄이기 전에 다시 출금 요청을 한다. 은행원은 내 계좌의 잔고를 줄이지 못한 채 계속해서 돈을 출금해준다. 이 과정을 반복해 계속해서 돈을 받는 것이다.“500원을 출금할 수 있을까요? 잠시만요, 그 전에.. 500원을 출금할 수 있을까요?”계좌의 잔고는 바닥나지 않기 때문에 출금 요청을 할 에너지(Gas)가 없을 때까지 계속해서 500원을 반복해서 출금할 수 있다. 시작 단계에서 단 한번 계좌 잔고에 500원 이상의 잔액이 남아 있는지 확인하도록 설계되어 있었기 때문에 이 공격이 가능했다.Mitigation돈이 전달되기 전에 sender의 계좌를 줄이면 된다. 병렬 프로그래밍을 다루는 사람들에게 익숙한 또 다른 해결방법은 뮤텍스5(mutex)를 사용하는 것이다. 모든 종류의 레이스 컨디션(race condition) 문제를 해결할 수 있다.현재, require(msg.sender.transfer(_value)를 사용하는 것이 이런 종류의 상황을 해결하는 가장 좋은 방법이다.  1 공격자는 언더플로우(Underflow) 취약점으로 토큰의 개수가 0개인 상태에서 소비할 경우, 토큰이 2256-1개로 늘어나는 것을 알고있다.  2 클래스와 클래스 맴버(변수 또는 함수)의 사용범위를 결정. 접근 제어자.  3 컨트랙트가 다른 컨트랙트를 호출하거나 EOA로 이더(Ether)를 보낼 때 사용.  4 트랜젝션을 실행하기 위한 수수료 단위. EVM에서 Bytecode를 실행할 때 가스(Gas)를 지불해야 코드를 실행할 수 있음.  5 공유된 자원을 여러 스레드(Thread)가 동시에 접근하는 것을 막음. 여러 풀 노드가 동시에 스마트 컨트랙트 바이트 코드(Bytecode)를 실행하는 것을 막을 수 있다."
  },
  
  {
    "title": "How to smell out in-house coin miners",
    "url": "/posts/HowToSmellOutInHouseCoinMiners/",
    "categories": "Security, Blockchain",
    "tags": "blockchain, mining, coin",
    "date": "2018-03-12 00:00:00 +0900",
    





    
    "snippet": "대다수 일본인들은 회사에서 휴대폰을 충전하는 행위를 ‘전기를 훔치는 일’이라고 생각하여 이를 엄격히 제재한다고 한다. 다만, 일본의 경우 한국과 달리 업무용 스마트폰을 지급하는 것이 보편적이다. 암호화폐를 생각해보자. 직원이 회사의 자원을 이용하여 암호화폐 채굴(Mining)을 한다면 이는 용인될 수 있을까? 인정 문화를 공유하는 한국에서 휴대폰 충전...",
    "content": "대다수 일본인들은 회사에서 휴대폰을 충전하는 행위를 ‘전기를 훔치는 일’이라고 생각하여 이를 엄격히 제재한다고 한다. 다만, 일본의 경우 한국과 달리 업무용 스마트폰을 지급하는 것이 보편적이다. 암호화폐를 생각해보자. 직원이 회사의 자원을 이용하여 암호화폐 채굴(Mining)을 한다면 이는 용인될 수 있을까? 인정 문화를 공유하는 한국에서 휴대폰 충전 정도는 너그러이 넘어갈 수 있지만, 상당한 양의 전력을 필요로 하는 채굴은 이야기가 다를 것이다.최근 암호화폐 채굴 악성코드가 유포되어 큰 문제가 되었다. 이 문제는 직원이 직접 채굴을 하는 문제보다 더 심각한 문제다. 많은 수의 서버와 PC를 감염시킬 수 있고, 상당한 양의 전기를 사용할 뿐만 아니라 회사에서 운영하고 있는 서비스에 영향을 미칠 수 있다. 이는 곧 회사의 이익(Profit)에 적지 않은 문제를 가져온다.  사내 PC 성능은 대부분 문서 작업에 적합한 수준이기 때문에 사내 암호화폐 채굴은 CPU Mining 으로 진행된다. GPU 또는 ASIC을 이용한 채굴에 비해 효율이 무척 낮은 편이지만, 노느니 염불 외는게 낫지 않은가.CPU Mining회사에서 암호화폐 채굴을 하는 경우 대부분 CPU를 이용한 채굴 방식을 사용한다. 고성능의 GPU나 ASIC 장비를 이용한 채굴이 일반적이지만 직원 PC나 서버에 고성능의 GPU가 없기 때문이다. CPU를 이용해 채굴할 수 있는 코인은 디지바이트(Digibyte-Skein, DGB), 모네로(XMR), ZCash(ZEC), ZCoin(XZC) 등이 있다.Stratum Mining Protocol채굴 프로그램 사용법을 보면 stratum+tcp 라는 스킴(scheme)을 사용하는 것을 알 수 있다.cpuminer 프로그램을 이용한 Zcoin 채굴 명령cpuminer.exe -a lyra2z -o stratum+tcp://miningpooladdress.com:1234 -u username.workername -p xstratum은 일반적인 TCP 소켓에 JSON-RPC 메시지로 인코딩된 페이로드를 담아 사용하는 채굴 프로토콜이다. 암호화폐의 종류와 상관없이 사용할 수 있다.JSON-RPC 메시지에 담기는 내용은 다음과 같다.  method: 클라이언트와 서버 사이에 호출되는 함수 명  params: 호출되는 함수에서 사용되는 파라미터통신하는 내용의 대부분은 “method”와 “params”를 확인하는 것으로 분석할 수 있다.Communication실제로 통신하는 내용을 살펴보면 다음과 같다.Mitigation패킷 탐지 규칙(Rule) 설정채굴 프로그램은 서버(채굴 풀)와 통신할 때 stratum+tcp 라는 특이한 프로토콜을 사용하고 있다. 앞서 알아본 바와 같이, mining.subscribe 라는 함수를 사용하여 서버(채굴 풀)와 통신을 시작한다.IDS 또는 IPS의 탐지 규칙(Rule)에 mining.subscribe, mining.authorize 그리고 mining.notify 등을 추가한다면 회사 내에서 채굴하는 행위를 막을 수 있다. 악성코드에 의해 사용자(또는 직원) 모르게 PC나 서버에서 채굴 프로그램이 동작하는 것도 차단할 수 있다.  서버와 연결되지 못한 채굴 프로그램은 CPU를 이용한 채굴을 시작하지 않는다. - CPU 점유율을 높이지 않는다.포트 그리고 서버(채굴 풀) 차단서버(채굴 풀)는 채굴을 위해 다양한 포트를 지원한다. 한국에서 가장 유명한 서버(채굴 풀)인 마이닝풀허브(https://miningpoolhub.com)는 12xxx, 17xxx 그리고 20xxx번 포트를 사용한다. 회사 정책에 의해 80 또는 443번 포트를 제외한 아웃바운드(outbound) 트래픽은 차단되기 때문에 이 서버를 이용해 채굴할 수 없다.채굴 악성코드는 이를 우회하여 80 또는 443번 포트를 이용한 채굴을 시도한다. 크립토 풀(https://monero.crypto-pool.fr)은 다양한 채굴 포트를 지원하고 있고, 모네로(XMR) 채굴 풀 중 가장 유명한 서버다.크립토 풀(crypto-pool)과 같은 서버(채굴 풀)에 대한 통신을 차단하여 사내 채굴 행위를 막을 수 있다. 물론, 악성코드에 의해 동작하는 채굴 프로그램도 차단할 수 있다.마지막으로 SSL 프로토콜을 이용해 채굴하는 경우도 있는데, 마찬가지로 채굴을 위해 사용하는 프로토콜인 stratum+tcp를 사용할 수 밖에 없기 때문에 대응 방법은 동일하다.  참고 : 전세계 채굴 풀 서버에 대한 실시간 정보 알림 사이트 https://investoon.com/"
  }
  
]

